{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Hermeto","text":"<p>Hermeto is a CLI tool that pre-fetches your project's dependencies to aid in making your build process hermetic.</p> <p>To see if we support your package manager(s), please check the package managers section.</p> <p>The primary intended use of Hermeto's outputs is for network-isolated container builds.</p>"},{"location":"#table-of-contents","title":"Table of contents","text":"<ul> <li>Goals</li> <li>Installation</li> <li>Basic usage</li> <li>Configuration</li> <li>Package managers</li> <li>Project status</li> </ul>"},{"location":"#goals","title":"Goals","text":"<p>Please note that Hermeto is rather picky, aiming to</p> <ul> <li>encourage or enforce best practices</li> <li>never execute arbitrary code <sup>1</sup></li> <li>keep the implementation simple</li> </ul> <p>To play nicely with Hermeto, the build process for your project must be</p> <ul> <li>Defined - Hermeto only fetches dependencies that are explicitly declared -   typically in a lockfile generated by your package manager.</li> <li>Reproducible - Hermeto will refuse to fetch a dependency if it's not   pinned to an exact version. This goes for transitive dependencies as well (and   ties to the Defined point). Most package managers pin all dependencies   automatically in lockfiles.</li> <li>Secure - Even with a lockfile, your build is not truly safe from supply   chain attacks unless you verify the checksums of all dependencies. If your   package manager supports specifying the expected checksums, we strongly   encourage you to make use of them.</li> </ul> <p>\u26a0 Hermeto will verify checksums if present, but doesn't require them by   default. This may change in the future.</p> <p>In return, Hermeto will help make your build</p> <ul> <li>Auditable - by generating a manifest of all the dependencies that go into   your build.</li> </ul> <p>The ability to achieve the goals depends on the build process being hermetic. Ideally, you should try to isolate the build from both the internet and the underlying host system to avoid implicit dependencies, unreproducible behavior and whole hosts of other issues. Hermeto itself is not a hermetic build system. We suggest you take advantage of existing technologies - such as containers - to achieve network isolation.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#standalone","title":"Standalone","text":"<p>We do not distribute Hermeto as a standalone package as of now.</p> <p>To install Hermeto for local development, see CONTRIBUTING.md.</p>"},{"location":"#container-image","title":"Container image","text":"<pre><code>ghcr.io/hermetoproject/hermeto\n</code></pre> <p>You may wish to set up an alias to make local usage more convenient</p> <pre><code>alias hermeto='podman run --rm -ti -v \"$PWD:$PWD:z\" -w \"$PWD\" ghcr.io/hermetoproject/hermeto:latest'\n</code></pre> <p>Note that the alias mounts the current working directory \u2014 the container will have access to files in that directory and nowhere else.</p>"},{"location":"#basic-usage","title":"Basic usage","text":"<pre><code>hermeto fetch-deps \\\n  --source ./my-repo \\\n  --output ./hermeto-output \\\n  --sbom-output-type cyclonedx \\\n  gomod\n</code></pre> <p>The <code>fetch-deps</code> command fetches your project's dependencies and stores them on your disk. Hermeto also produces a detailed SBOM containing information about all the project's components and packages. You can find the SBOM in the output directory.</p> <p>See <code>docs/usage.md</code> for a more detailed, practical example of Hermeto usage.</p> <p>You might also like to check out <code>hermeto --help</code> and the <code>--help</code> texts of the available subcommands.</p>"},{"location":"#configuration","title":"Configuration","text":""},{"location":"#modes","title":"Modes","text":"<p>Hermeto can be run in two modes using the global CLI option <code>--mode</code>.</p> <ul> <li>strict</li> <li>permissive</li> </ul> <p>The default mode is <code>strict</code>. In this mode, some input requirements that are not met are treated as errors. On the other hand, the <code>permissive</code> mode treats them as warnings. This means that Hermeto will proceed and generate an SBOM, but it may not be complete or accurate.</p> <p>The permissive mode can currently suppress the following:</p> <ul> <li>go <code>vendor</code> directory inconsistencies (See <code>docs/gomod.md</code> on vendoring   information)</li> <li>cargo manifest file <code>Cargo.toml</code> is out of sync with <code>Cargo.lock</code></li> </ul>"},{"location":"#settings","title":"Settings","text":"<p>Settings can be provided via the following sources (highest priority first):</p> <ol> <li>Environment variables: prefixed with <code>HERMETO_</code>, using <code>__</code> for nested    settings (e.g., <code>HERMETO_GOMOD__DOWNLOAD_MAX_TRIES=10</code>)</li> <li>CLI option: <code>--config-file path/to/config.yaml</code></li> <li>Config files (automatically loaded if present): <code>~/.config/hermeto/config.yaml</code>,    <code>hermeto.yaml</code>, <code>.hermeto.yaml</code></li> </ol> <p>Any settings specified will override the default values present in the config.py module. The only supported format for config files is YAML.</p> <ul> <li><code>gomod.download_max_tries</code> max retry attempts for go commands.</li> <li><code>gomod.environment_variables</code> default environment variables for gomod.</li> <li><code>gomod.proxy_url</code> sets the GOPROXY variable that Hermeto uses internally when   downloading Go modules. See Go environment variables.</li> <li><code>http.connect_timeout</code> connection timeout (seconds) for HTTP requests   (default: 30).</li> <li><code>http.read_timeout</code> read timeout (seconds) for HTTP requests (default: 300).   Long-running downloads can take arbitrarily long as long as bytes keep   flowing.</li> <li><code>http.timeout</code> (deprecated) automatically migrated to <code>http.read_timeout</code>.</li> <li><code>runtime.concurrency_limit</code> max concurrent operations.</li> <li><code>runtime.subprocess_timeout</code> timeout (seconds) for subprocess commands.</li> </ul>"},{"location":"#package-managers","title":"Package managers","text":"Package manager Ecosystem bundler Ruby cargo Rust generic N/A gomod Go npm JavaScript pip Python rpm RPM yarn JavaScript"},{"location":"#bundler","title":"bundler","text":"<p>Hermeto supports bundler by parsing the Gemfile.lock file present in the source repository and downloading the declared dependencies.</p> <p>To generate a lockfile or to make sure the file is up to date, you can use for example the <code>bundle lock</code> command, which generates the <code>Gemfile.lock</code> file based on the dependencies specified in the Gemfile. Both files must be present in the source repository so you should check them into your git repository.</p> <p>See docs/bundler.md for more details.</p>"},{"location":"#cargo","title":"cargo","text":"<p>Hermeto supports Cargo by invoking the Cargo CLI to fetch Rust dependencies as declared in your project, ensuring reproducible builds with explicitly defined versions. Make sure to have up-to-date Cargo.lock present in your project.</p> <p>See docs/cargo.md for more details.</p>"},{"location":"#generic-fetcher","title":"generic fetcher","text":"<p>Generic fetcher is a way for Hermeto to support prefetching arbitrary files that don't fit into other package managers. With the generic fetcher, you can easily fetch those files with Hermeto along with your other language-specific dependencies, satisfy the hermetic build condition and have them recorded in the SBOM.</p> <p>Hermeto uses a simple custom lockfile named <code>artifacts.lock.yaml</code> that is expected to be present in the repository, or supplied in JSON input. The lockfile describes the urls, checksums and output filenames for the downloaded files.</p> <p>Currently supported types of artifacts</p> <ul> <li>Arbitrary files</li> <li>Maven artifacts</li> </ul> <p>See docs/generic.md for more details.</p>"},{"location":"#gomod","title":"gomod","text":"<p>Current version: 1.25 <sup>2</sup> <sup>3</sup></p> <p>The gomod package manager works by parsing the go.mod file present in the source repository to determine which dependencies to download. Hermeto does not parse this file on its own - rather, we rely on the <code>go</code> command to download and list the required dependencies.</p> <p>From Go 1.17 onward, the go.mod file includes all the transitively required dependencies of your application - see the section about Pruned module graphs in the Go 1.17 changelog. In previous Go versions, the go.mod file included only direct dependencies. Hermeto does support downloading and listing all transitive dependencies for earlier versions thanks to Go's backwards compatibility<sup>3</sup>. Note that using Go &gt;= 1.17 in your project has the added benefit of downloading fewer dependencies (as noted in the changelog), in some cases drastically so.</p> <p>See docs/gomod.md for more details.</p>"},{"location":"#npm","title":"npm","text":"<p>Hermeto supports npm by parsing package-lock.json file present in the source repository and downloading the declared dependencies.</p> <p>To generate lockfile or to make sure the file is up to date, you can use npm install.</p> <p>Make sure lockfile version is higher than v1 (Node.js 15 or higher).</p> <p>See docs/npm.md for more details.</p>"},{"location":"#pip","title":"pip","text":"<p>Hermeto supports pip by parsing requirements.txt files present in the source repository and downloading the declared dependencies.</p> <p>The files must be lockfiles, i.e. declare all the transitive dependencies and pin them to specific versions. Generating such a lockfile is best done using tools like pip-compile</p> <p>We support source distribution file format (sdist) as well as binary distribution file format (wheel).</p> <p>See docs/pip.md for more details.</p>"},{"location":"#rpm","title":"rpm","text":"<p>Hermeto supports rpm by parsing the <code>rpms.lock.yaml</code> file present in the source repository and downloading the declared dependencies. To generate this YAML \"lockfile\", one can currently only use rpm-lockfile-prototype for this job.</p> <p>See docs/rpm.md for more details.</p>"},{"location":"#yarn","title":"yarn","text":"<p>Current version: v4</p> <p>Unlike NPM, hermeto merely drives the underlying <code>yarn</code> CLI command operations, that is, hermeto leaves most of the heavy lifting to Yarn itself and it mainly focuses on post-process validation. Note that having a Yarn lockfile (<code>yarn.lock</code>) checked into the repository is paramount for hermeto to process a project successfully. If missing, you can easily generate one by running yarn install prior to pointing hermeto to your project.</p> <p>See docs/yarn.md for more details.</p>"},{"location":"#project-status","title":"Project status","text":"<p>Hermeto was derived from (but is not a direct fork of) Cachito.</p> <ol> <li> <p>See for example this python.org discussion \u21a9</p> </li> <li> <p>Hermeto expects to use a specific version of the <code>go</code> command   when downloading dependencies. This is the version installed in the   hermeto container. We do not guarantee correctness if you   run Hermeto locally (outside the container) with a different Go version.   You are free to use a different version to build your project.\u00a0\u21a9</p> </li> <li> <p>The <code>go</code> command promises to be backwards compatible with previous   versions. If your go.mod file specifies the intended go version, Hermeto   should handle it appropriately. If your go version is higher than what   Hermeto uses, there is a good chance it will be compatible regardless, as long   as the dependency resolution did not change between the two versions.   For example, dependency resolution did change in Go 1.18 but not in   Go 1.19. Things are a bit more complicated with Go 1.21, if you are or   have been experiencing issues with hermeto related to Go 1.21+, please refer   to our gomod documentation for more details.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"bundler/","title":"Bundler","text":""},{"location":"bundler/#prerequisites","title":"Prerequisites","text":"<p>To use Hermeto with Bundler locally, ensure you have Ruby and Bundler installed on your system.</p> <pre><code>sudo dnf install rubygem-bundler\n</code></pre> <p>Then ensure you have both, Gemfile and Gemfile.lock in your project directory. We parse the Gemfile.lock to pre-fetch all dependencies specified in that file.</p>"},{"location":"bundler/#basic-usage","title":"Basic usage","text":"<p>Run the following command in your terminal to pre-fetch your project's dependencies. The command will download all dependencies specified in the Gemfile.lock to the specified output directory.</p> <pre><code>cd path-to-your-ruby-project\nhermeto fetch-deps bundler\n</code></pre> <p>In addition, it will prepare the necessary environment variables and configuration files for the build phase. See the following sections for more information.</p>"},{"location":"bundler/#gems","title":"Gems","text":"<p>Each gem has a name, version, and platform. If the platform is \"ruby\", it means that it should work on any platform Ruby runs on. Using the ruby platform means ignoring the current machine's platform and installing only ruby platform gems. As a result, gems with native extensions will be compiled from the source.</p> <p>However, occasionally some gems do not have a version for the ruby platform and are only available as pre-compiled binaries. In this case, you may need to enable the pre-fetching of gems for specific platforms using the <code>binary</code> field when running the <code>fetch-deps</code> command.</p> <p>WARNING</p> <p>The <code>binary</code> field is not fully supported yet. When the <code>binary</code> field is specified, no platform filtering is performed. Instead, all available pre-compiled gems from the Gemfile.lock are downloaded, regardless of platform-specific requirements. See #1075.</p>"},{"location":"bundler/#configuration","title":"Configuration","text":"<p>Bundler uses an unorthodox system when dealing with configuration options. The highest precedence is given to the config file, and then to the environment variables. This is a current limitation of Bundler, that we had to work around. We may drop the workaround if this ends up being addressed in future Bundler releases.</p> <p>The order of precedence for Bundler configuration options is as follows</p> <ol> <li>Local config (<code>&lt;project_root&gt;/.bundle/config or $BUNDLE_APP_CONFIG/config</code>)</li> <li>Environment variables (ENV)</li> <li>Global config (<code>~/.bundle/config</code>)</li> <li>Bundler default config</li> </ol> <p>We set the following configuration options to ensure that the build process works correctly</p> <ul> <li>BUNDLE_CACHE_PATH: \"${output_dir}/deps/bundler\"</li> <li>BUNDLE_DEPLOYMENT: \"true\"</li> <li>BUNDLE_NO_PRUNE: \"true\"</li> <li>BUNDLE_VERSION: \"system\"</li> <li>BUNDLE_ALLOW_OFFLINE_INSTALL: \"true\"</li> <li>BUNDLE_DISABLE_VERSION_CHECK: \"true\"</li> </ul>"},{"location":"bundler/#bundle_cache_path","title":"BUNDLE_CACHE_PATH","text":"<p>The directory that Bundler will look into when installing gems.</p>"},{"location":"bundler/#bundle_deployment","title":"BUNDLE_DEPLOYMENT","text":"<p>Disallow changes to the Gemfile. When the Gemfile is changed and the lockfile has not been updated, running Bundler commands will be blocked. More importantly though, this makes Bundler comply with network isolated builds. However, this setting has a user-side implication regarding their build recipes, e.g. Dockerfiles[^1] and you may want to consider enforcing the installation path for your app explicitly with <code>BUNDLE_PATH</code></p>"},{"location":"bundler/#bundle_no_prune","title":"BUNDLE_NO_PRUNE","text":"<p>Leave outdated gems unpruned.</p>"},{"location":"bundler/#bundle_version","title":"BUNDLE_VERSION","text":"<p>The version of Bundler to use when running under the Bundler environment.</p>"},{"location":"bundler/#bundle_allow_offline_install","title":"BUNDLE_ALLOW_OFFLINE_INSTALL","text":"<p>Allow Bundler to use cached data when installing without network access.</p>"},{"location":"bundler/#bundle_disable_version_check","title":"BUNDLE_DISABLE_VERSION_CHECK","text":"<p>Stop Bundler from checking if a newer Bundler version is available on rubygems.org.</p> <p>NOTE</p> <p>A prefetch could fail when Bundler versions differ between the build system and lockfile and when the former is outdated. Therefore we do not recommend using mismatching or outdated versions of Bundler in build systems as this might result in unexpected failures.*</p> <p>To create the configuration file, run the following command.</p> <pre><code>hermeto inject-files --for-output-dir /tmp/hermeto-output hermeto-output\n</code></pre> <p>You should see a log message that the file was created successfully. Lastly, you need to set the <code>BUNDLE_APP_CONFIG</code> environment variable to point to the copied configuration file.</p> <pre><code>hermeto generate-env --output ./hermeto.env --for-output-dir /tmp/hermeto-output ./hermeto-output\n</code></pre> <pre><code># cat hermeto.env\nexport BUNDLE_APP_CONFIG=/tmp/hermeto-output/bundler/config_override\n</code></pre> <p>The generated environment file should be sourced before running any Bundler command.</p>"},{"location":"bundler/#limitations","title":"Limitations","text":"<p>Since the local configuration takes higher precedence than the environment variables (except <code>BUNDLE_APP_CONFIG</code>), we copy the configuration file and overwrite the environment variables above. Then, we change the <code>BUNDLE_APP_CONFIG</code> environment variable to point to the new configuration file.</p> <p>It should not affect the build process unless you have multiple packages in your repository with different configuration settings. In that case, you may have to adjust the build phase accordingly.</p>"},{"location":"bundler/#hermetic-build","title":"Hermetic build","text":"<p>After using the <code>fetch-deps</code>, <code>inject-files</code>, and <code>generate-env</code> commands to set up the directory, building the Dockerfile will produce a container with the application fully compiled without any network access. The build will be hermetic and reproducible.</p> <pre><code>FROM docker.io/library/ruby:latest\n\nWORKDIR /app\n\nCOPY Gemfile .\nCOPY Gemfile.lock .\n\n...\n\nRUN . /tmp/hermeto.env &amp;&amp; bundle install\n\n...\n</code></pre> <p>Assuming <code>hermeto-output</code> and <code>hermeto.env</code> are in the same directory as the Dockerfile, build the image with the following command</p> <pre><code>podman build . \\\n  --volume \"$(realpath ./hermeto-output)\":/tmp/hermeto-output:Z \\\n  --volume \"$(realpath ./hermeto.env)\":/tmp/hermeto.env:Z \\\n  --network none \\\n  --tag my-ruby-app\n</code></pre>"},{"location":"bundler/#unsupported-features","title":"Unsupported features","text":"<ul> <li>checksum validation (blocked by pending official support)</li> <li>downloading the Bundler version specified in the Gemfile.lock</li> <li>reporting development dependencies</li> <li>plugins</li> </ul> <p>[^1] <code>BUNDLE_DEPLOYMENT</code> enforces deployment mode which is essentially vendoring your application and its dependencies. In other words, deployment will install your application to a local <code>vendor/bundle</code> directory instead of using the standard system-wide location. This is currently the only way of forcing bundler to respect and use the offline package cache during hermetic builds. Note that the deployment mode doesn't play nicely with other installation flags and so trying to use <code>--local</code> with your <code>bundle install</code> command in your Dockerfile won't take effect, consider <code>BUNDLE_PATH</code> instead.</p>"},{"location":"cargo/","title":"Cargo","text":""},{"location":"cargo/#prerequisites","title":"Prerequisites","text":"<p>To use Hermeto with Cargo locally, ensure you have the Cargo binary installed on your system. Then, ensure that the Cargo.toml and Cargo.lock are in your project directory.</p>"},{"location":"cargo/#usage","title":"Usage","text":"<p>Run the following commands in your terminal to prefetch your project's dependencies specified in the Cargo.lock. It must be synchronized with the Cargo.toml file. Otherwise, the command will fail.</p> <pre><code>cd path-to-your-rust-project\nhermeto fetch-deps cargo\n</code></pre> <p>The default output directory is <code>hermeto-output</code>. You can change it by passing the <code>--output-dir</code> option for the <code>fetch-deps</code> command. See the help message for more information.</p> <p>After prefetching the dependencies, you can use the <code>hermeto inject-files</code> command to update the <code>.cargo/config.toml</code> file in your project directory. If it does not exist, it will be created. The file will contain instructions for Cargo to use the prefetched dependencies when compiling a project.</p> <p>Use the <code>--for-output-dir</code> option to specify the location where you want to mount the <code>hermeto-output</code> in your container build environment. See the next section.</p> <p>Do not forget to copy <code>.cargo/config.toml</code> when building your container image.</p> <pre><code>hermeto inject-files --for-output-dir /tmp/hermeto-output hermeto-output\n</code></pre> <p>There are no environment variables that need to be set for the build phase.</p>"},{"location":"cargo/#hermetic-build","title":"Hermetic build","text":"<p>After using the <code>fetch-deps</code>, and <code>inject-files</code> commands to set up the directory, you can build your project hermetically. Here is an example of a Dockerfile with basic instructions to build a Rust project</p> <pre><code>FROM docker.io/library/rust:latest\n\nWORKDIR /app\n\nCOPY Cargo.toml Cargo.lock .cargo .\n\nRUN cargo build --release\n</code></pre> <p>Do not forget to mount the <code>hermeto-output</code> directory to the container build environment.</p> <pre><code>podman build . \\\n  --volume \"$(realpath ./hermeto-output)\":/tmp/hermeto-output:Z \\\n  --network none \\\n  --tag my-rust-app\n</code></pre>"},{"location":"cargo/#limitations","title":"Limitations","text":""},{"location":"cargo/#resolver-v3-and-msrv-aware-resolution","title":"Resolver v3 and MSRV-aware resolution","text":"<p>Hermeto configures Cargo to work without requiring <code>rustc</code> in the container. To achieve this, Hermeto sets <code>CARGO_RESOLVER_INCOMPATIBLE_RUST_VERSIONS=allow</code> when running <code>cargo vendor</code>.</p> <p>Impact: None. Hermeto uses <code>cargo vendor --locked</code> which vendors the exact versions from your Cargo.lock file. Any MSRV-aware resolution choices you made when generating the lock file are fully preserved.</p> <p>Note: The only exception is PERMISSIVE mode when Cargo.lock is out-of-sync with Cargo.toml. In this case, Hermeto regenerates the lock file without MSRV-aware resolution, potentially selecting newer dependency versions than your <code>rust-version</code> supports.</p>"},{"location":"generic/","title":"Generic fetcher","text":"<ul> <li>Specifying artifacts to fetch</li> <li>Using fetched dependencies</li> <li>Full example walkthrough</li> </ul>"},{"location":"generic/#support-scope","title":"Support scope","text":"<p>Generic fetcher is made specifically for use cases where hermeto will not implement a full package manager support, or for ecosystems where no such package manager exists. It is highly discouraged for this feature to be used for anything already supported by hermeto in other ways (such as e.g. pip packages), because the produced SBOM component will not be accurate.</p>"},{"location":"generic/#specifying-artifacts-to-fetch","title":"Specifying artifacts to fetch","text":"<p>The generic fetcher requires a lockfile <code>artifacts.lock.yaml</code> that specifies which files to download. This file is expected to be in the source repository. Alternatively, a different filename or location can be supplied via the <code>lockfile</code> key in the JSON input to hermeto. The value may be either an absolute path or a path relative to the package <code>path</code>.</p> <p>Below are sections for each type of supported artifact. Several artifacts of different types can be specified in a single lockfile.</p> <p>The lockfile must always contain a <code>metadata</code> header and a list of <code>artifacts</code>. Currently, the only supported version is 1.0:</p> <pre><code>---\nmetadata:\n  version: \"1.0\"\nartifacts: []\n</code></pre> <p>Hermeto can be run as follows</p> <pre><code>hermeto fetch-deps \\\n  --source ./my-repo \\\n  --output ./hermeto-output \\\n  '&lt;JSON input&gt;'\n</code></pre> <p>where 'JSON input' is</p> <pre><code>{\n  \"type\": \"generic\",\n  // path to the package (relative to the --source directory)\n  // defaults to \".\"\n  \"path\": \".\",\n  // option to specify lockfile path: absolute or relative to package path\n  // defaults to \"artifacts.lock.yaml\", resolved relative to package path\n  \"lockfile\": \"artifacts.lock.yaml\",\n}\n</code></pre>"},{"location":"generic/#arbitrary-files","title":"Arbitrary files","text":"<p>This artifact type is intended for whatever files are needed at build time that do not fit neatly into other package managers.</p> <pre><code>---\nmetadata:\n  version: \"1.0\"\nartifacts:\n  - download_url: \"https://example.com/file.zip\"\n    checksum: \"algorithm:hash\"\n    filename: \"optional-custom-name.zip\"  # optional\n</code></pre> <p>Each artifact requires:</p> <ul> <li><code>download_url</code> The URL to download the file from</li> <li><code>checksum</code> In format \"algorithm:hash\" (e.g., \"sha256:123...\")</li> <li><code>filename</code> Optional custom filename for the downloaded file. If not present,   it will be derived from the url</li> </ul>"},{"location":"generic/#arbitrary-sbom-component","title":"Arbitrary SBOM component","text":"<p>Since there can't be any assumptions about these files beyond checking their identity against a checksum, these files will be reported with <code>pkg:generic</code> purl in the output SBOM.</p>"},{"location":"generic/#maven-artifacts","title":"Maven artifacts","text":"<p>This type is for downloading maven repository artifacts. These are specified using GAV coordinates that are enumerated in the artifact's attributes in the lockfile. The download URL will be assembled using this information.</p> <pre><code>---\nmetadata:\n    version: \"1.0\"\nartifacts:\n    - type: \"maven\"\n      filename: \"ant.jar\"\n      attributes:\n          repository_url: \"https://repo1.maven.org/maven2\"\n          group_id: \"org.apache.ant\"\n          artifact_id: \"ant\"\n          version: \"1.10.14\"\n          type: \"jar\"\n      checksum: \"sha256:4cbbd9243de4c1042d61d9a15db4c43c90ff93b16d78b39481da1c956c8e9671\"\n</code></pre> <p>Each artifact requires</p> <ul> <li><code>type</code> type of the artifact (always <code>maven</code>)</li> <li><code>filename</code> Optional custom filename for the downloaded file. If not present,   it will be derived from the url</li> <li> <p><code>attributes</code> Maven-specific attributes</p> </li> <li> <p><code>repository_url</code> URL of the Maven repository (required)</p> </li> <li><code>group_id</code> Maven group ID  (required)</li> <li><code>artifact_id</code> Maven artifact ID  (required)</li> <li><code>version</code> Version of the artifact (required)</li> <li><code>type</code> Type of the artifact (\"jar\" by default)</li> <li> <p><code>classifier</code> Maven classifier (optional)</p> </li> <li> <p><code>checksum</code> In format \"algorithm:hash\" (e.g., \"sha256:123...\")</p> </li> </ul>"},{"location":"generic/#maven-sbom-component","title":"Maven SBOM component","text":"<p>These files will be reported with <code>pkg:maven</code> purl in the output SBOM, because the URL is fully assembled from the provided attributes and therefore the file can be assumed to be a maven artifact.</p>"},{"location":"generic/#using-fetched-dependencies","title":"Using fetched dependencies","text":"<p>Hermeto downloads the files into the <code>deps/generic/</code> subpath of the output directory. Files are named according to the <code>filename</code> field if specified, otherwise derived from the URL. During your build, you would typically mount hermeto's output directory into your container image and reference the individual files.</p> <p>See the Example below for a complete walkthrough of Hermeto usage.</p>"},{"location":"generic/#example","title":"Example","text":"<p>Generic fetcher is a package manager that can fetch arbitrary files. Let's build a sample container image that would be inconvenient to build hermetically otherwise. This image will provide OWASP Dependency check tool, which is available to install from GitHub releases page. Get the repo if you want to try for yourself</p> <pre><code>git clone -b sample-app https://github.com/cachito-testing/cachi2-generic.git\n</code></pre>"},{"location":"generic/#pre-fetch-dependencies","title":"Pre-fetch dependencies","text":"<p>In order to retrieve the archive with the tool, either a <code>artifacts.lock.yaml</code> needs to be in the repository, or a lockfile path needs to be supplied in the JSON input (either an absolute path or a path relative to the package <code>path</code>). You can find a sample lockfile below. It is identical to the one found in the sample repository. A lockfile for the generic fetcher must contain a <code>metadata</code> header and a list of artifacts, where each artifact is represented as a pair of URL and a checksum string in the format of <code>\"algorithm:checksum\"</code>. Optionally, you can also specify an output <code>filename</code> for the artifact. If not specified, it will be derived from the url.</p> <pre><code>---\nmetadata:\n  version: \"1.0\"\nartifacts:\n  - download_url: \"https://github.com/jeremylong/DependencyCheck/releases/download/v11.1.0/dependency-check-11.1.0-release.zip\"\n    checksum: \"sha256:c5b5b9e592682b700e17c28f489fe50644ef54370edeb2c53d18b70824de1e22\"\n    filename: \"dependency-check.zip\"\n</code></pre> <p>As with other examples, the command to fetch dependencies is very similar. The default path is assumed to be <code>.</code>.</p> <pre><code>hermeto fetch-deps --source ./hermeto-generic --output ./hermeto-output generic\n</code></pre>"},{"location":"generic/#build-the-application-image","title":"Build the application image","text":"<p>We'll use the <code>ibmjava:11-jdk</code> as base image because it already has java pre-installed. During the build, the downloaded release will be extracted and modified to have execute rights.</p> <pre><code>FROM ibmjava:11-jdk\n\nWORKDIR /tmp\n\n\n# use jar to unzip file in order to avoid having to install more dependencies\nRUN jar -xvf hermeto-output/deps/generic/dependency-check.zip\n\nRUN chmod +x dependency-check/bin/dependency-check.sh\n\nENTRYPOINT [\"/tmp/dependency-check/bin/dependency-check.sh\", \"--version\"]\n</code></pre> <p>We can then build the image as before while mounting the required Hermeto data.</p> <pre><code>podman build . \\\n  --volume \"$(realpath ./hermeto-output)\":/tmp/hermeto-output:Z \\\n  --network none \\\n  --tag sample-generic-app\n</code></pre>"},{"location":"gomod/","title":"gomod","text":"<ul> <li>Specifying modules to process</li> <li>Using fetched dependencies</li> <li>gomod flags</li> <li>Vendoring</li> <li>Understanding reported dependencies</li> <li>Go 1.21+</li> <li>Full example walkthrough</li> </ul>"},{"location":"gomod/#specifying-modules-to-process","title":"Specifying modules <sup>1</sup> to process","text":"<p>Hermeto can be run as follows</p> <pre><code>hermeto fetch-deps \\\n  --source ./my-repo \\\n  --output ./hermeto-output \\\n  '&lt;JSON input&gt;'\n</code></pre> <p>where 'JSON input' is</p> <pre><code>{\n  // \"gomod\" tells Hermeto to process a go module\n  \"type\": \"gomod\",\n  // path to the module (relative to the --source directory)\n  // defaults to \".\"\n  \"path\": \".\"\n}\n</code></pre> <p>The main argument accepts alternative forms of input, see Example: Pre-fetch dependencies for details.</p>"},{"location":"gomod/#using-fetched-dependencies","title":"Using fetched dependencies","text":"<p>See the Example for a complete walkthrough of Hermeto usage.</p> <p>Hermeto downloads the required modules into the deps/gomod/ subpath of the output directory (<code>hermeto-output/deps/gomod</code>). Further down the file tree, at <code>hermeto-output/deps/gomod/pkg/mod</code>, is a directory formatted as the Go module cache</p> <pre><code>hermeto-output/deps/gomod/pkg/mod\n\u2514\u2500\u2500 cache\n    \u2514\u2500\u2500 download\n        \u251c\u2500\u2500 github.com\n        \u2502   \u2514\u2500\u2500 ...\n        \u2514\u2500\u2500 golang.org\n            \u2514\u2500\u2500 ...\n</code></pre> <p>To use this module cache during your build, set the GOMODCACHE environment variable. Hermeto generates GOMODCACHE along with other expected environment variables for you. See Example: Generate environment variables for more details.</p> <p>For more information on Go's environment variables</p> <pre><code>go help environment\n</code></pre> <p>Note that the deps/gomod/ layout described above does not apply when using vendoring. With vendoring enabled, deps/gomod/ will be an empty directory. Instead, dependencies will be inside the vendor subdirectory of your module.</p> <pre><code>my-repo\n\u2514\u2500\u2500 vendor\n    \u251c\u2500\u2500 github.com\n    \u2502   \u2514\u2500\u2500 ...\n    \u251c\u2500\u2500 golang.org\n    \u2502   \u2514\u2500\u2500 ...\n    \u2514\u2500\u2500 modules.txt\n</code></pre> <p>Go will use the vendored dependencies automatically, but it's not a bad idea to set the environment variables generated by Hermeto anyway.</p>"},{"location":"gomod/#gomod-flags","title":"gomod flags","text":"<p>The <code>hermeto fetch-deps</code> command accepts the following gomod-related flags</p>"},{"location":"gomod/#-cgo-disable","title":"--cgo-disable","text":"<p>Makes Hermeto internally disable cgo while processing your Go modules. Typically, you would want to use this flag if your modules do use C code and Hermeto is failing to process them. Hermeto will not attempt to disable cgo in your build (nor should you disable it yourself if you rely on C).</p> <p>Disabling cgo should not prevent Hermeto from fetching your Go dependencies as usual. Note that Hermeto will not make any attempts to fetch missing C libraries. If required, you would need to get them through other means.</p>"},{"location":"gomod/#deprecated-flags","title":"Deprecated flags","text":"<ul> <li><code>--gomod-vendor</code> (deprecated in v0.11.0)</li> <li><code>--gomod-vendor-check</code> (deprecated in v0.11.0)</li> <li><code>--force-gomod-tidy</code> (deprecated in v0.18.0)</li> </ul> <p>All of them are deprecated and will have no effect when set. They are only kept for backwards compatibility reasons and will be removed in future releases.</p>"},{"location":"gomod/#vendoring","title":"Vendoring","text":"<p>Go supports vendoring to store the source code of all dependencies in the vendor/ directory alongside your module. Before go 1.17, <code>go mod vendor</code> used to download fewer dependencies than <code>go mod download</code>. Starting with 1.17, that is no longer true.</p> <p>We generally discourage vendoring, but Hermeto does support processing repositories that contain vendored content. In this case, instead of a regular prefetching of dependencies, Hermeto will only validate if the contents of the vendor directory are consistent with what <code>go mod vendor</code> would produce.</p>"},{"location":"gomod/#understanding-reported-dependencies","title":"Understanding reported dependencies","text":"<p>Hermeto reports two (arguably three) different types of dependencies in the generated SBOM for your Go modules</p> <ul> <li>gomod dependencies (Go modules)</li> <li> <p>go-package dependencies (Go packages)</p> </li> <li> <p>from the downloaded modules</p> </li> <li>from the standard library</li> </ul>"},{"location":"gomod/#gomod-vs-go-package","title":"gomod vs go-package","text":"<p>Best explained by the Go modules documentation</p> <p>A module is a collection of packages that are released, versioned, and distributed together.</p> <p>Your Go code imports individual packages, which come from modules. You might import a single package from a module that provides many, but Go (and Hermeto) has to download the whole module anyway. Effectively, modules are the smallest \"unit of distribution.\" Go does have the ability to list the individual packages that your project imports. Hermeto makes use of this ability to report both the downloaded modules and the required packages.</p> <p>The list of go-package dependencies reported by Hermeto is the full set of packages (transitively) required by your project.</p> <p>\u26a0 If any of your module dependencies has a missing checksum in go.sum, the list may be incomplete.</p> <p>The list of gomod dependencies is the set of modules that Hermeto downloaded to satisfy the go-package dependencies.</p> <p>Note that versioning applies to modules, not packages. When reporting the versions of Go packages, Hermeto uses the version of the module that provides the package.</p>"},{"location":"gomod/#how-to-match-a-package-to-a-module","title":"How to match a package to a module?","text":"<p>Borrowing from the Go modules documentation again</p> <p>For example, the module \"golang.org/x/net\" contains a package in the directory \"html\". That package\u2019s path is \"golang.org/x/net/html\"</p> <p>The name of a package starts with the name of the module that provides it.</p>"},{"location":"gomod/#in-the-source-tree-what-are-modules-what-are-packages","title":"In the source tree, what are modules? What are packages?","text":"<p>To simplify a little</p> <ul> <li>Does the directory have a <code>go.mod</code> file? It's a module (provides packages).</li> <li>Does the directory have any <code>*.go</code> files? It's a package (is importable).</li> <li>Does it have both? It's both a module and a package.</li> </ul>"},{"location":"gomod/#stdlib-dependencies","title":"stdlib dependencies","text":"<p>Go is able to list even the standard library packages that your project imports. Hermeto exposes these as go-package dependencies, with caveats. Hermeto uses some version of Go to list the dependencies. This may or may not be the same version that you will use to build your project. We do not presume that the versions would be the same, hence why:</p> <ul> <li>the reported stdlib packages may be slightly inaccurate (e.g. new packages in   new Go versions)</li> <li>the versions of stdlib packages are not reported</li> </ul>"},{"location":"gomod/#what-identifies-stdlib-dependencies-in-the-go-package-list","title":"What identifies stdlib dependencies in the go-package list?","text":"<ul> <li>does not have a version</li> <li> <p>the name does not start with a hostname</p> </li> <li> <p><code>io/fs</code> - standard library</p> </li> <li><code>golang.org/x/net</code> - external</li> </ul>"},{"location":"gomod/#missing-checksums","title":"Missing checksums","text":"<p>Go stores the checksums of all your dependency modules in the go.sum file. Go typically manages this file entirely on its own, but if any of your dependencies do end up missing, it can cause issues for Hermeto and for Go itself.</p> <p>For Hermeto, a missing checksum means that the offending module gets downloaded without checksum verification (or with partial checksum verification - Hermeto does consult the Go checksum database). Due to <code>go list</code> behavior, it also means that the go-package dependency listing may be incomplete<sup>2</sup>.</p> <p>For Go, a missing checksum will cause the <code>go build</code> or <code>go run</code> commands to fail.</p> <p>Please make sure to keep your go.sum file up to date, perhaps by incorporating the <code>go mod tidy</code> command in your dev workflow.</p>"},{"location":"gomod/#go-121-since-v050","title":"Go 1.21+ (since v0.5.0)","text":"<p>Starting with Go 1.21, Go changed the meaning of the <code>go 1.X</code> directive in that it now specifies the minimum required version of Go rather than a suggested version as it originally did. The format of the version string in the <code>go</code> directive now also includes the micro release and if you don't include the micro release in your <code>go.qmod</code> file yourself (i.e. you only specify the language release) Go will try to correct it automatically inside the file. Last but not least, Go 1.21 also introduced a new keyword <code>toolchain</code> to the <code>go.mod</code> file. What this all means in practice for end users is that you may not be able to process your <code>go.mod</code> file with an older version of Go (and hence older hermeto) as you could in the past for various reasons. Many projects bump their required Go toolchain's micro release as soon as it becomes available upstream (i.e. not waiting for distributions to bundle them properly). This caused problems in version v0.5.0 because the container image's version simply may not have been high enough to process a given project's <code>go.mod</code> file. Therefore, version v0.7.0 introduced a mechanism to always rely on the origin 0th release of a toolchain (e.g. 1.21.0) and use the <code>GOTOOLCHAIN=auto</code> setting to instruct Go to fetch any toolchain as specified by the <code>go.mod</code> file automatically, hence allowing us to keep up with frequent micro version bumps. Note that such a language version would still need to be officially marked as supported by hermeto, i.e. we'd not allow Go to fetch e.g. a 1.22 toolchain if the maximum supported Go version by hermeto were 1.21!</p>"},{"location":"gomod/#example","title":"Example","text":"<p>Let's show Hermeto usage by building the glorious fzf CLI tool hermetically. To follow along, clone the repository to your local disk.</p> <pre><code>git clone https://github.com/junegunn/fzf --branch=0.34.0\n</code></pre>"},{"location":"gomod/#pre-fetch-dependencies","title":"Pre-fetch dependencies","text":"<p>In order to pre-fetch the dependencies, we will pass the source and output directories as well as the path for the <code>gomod</code> package manager to be able to find the <code>go.mod</code> file.</p> <p>See the gomod documentation for more details about running Hermeto for pre-fetching gomod dependencies.</p> <pre><code>hermeto fetch-deps \\\n  --source ./fzf \\\n  --output ./hermeto-output \\\n  '{\"path\": \".\", \"type\": \"gomod\"}'\n</code></pre>"},{"location":"gomod/#generate-environment-variables","title":"Generate environment variables","text":"<p>Next, we need to generate the environment file so that the <code>go build</code> command can find the cached dependencies</p> <pre><code>hermeto generate-env ./hermeto-output -o ./hermeto.env --for-output-dir /tmp/hermeto-output\n</code></pre> <p>We can see the variables needed by the compiler</p> <pre><code>$ cat hermeto.env\nexport GOCACHE=/tmp/hermeto-output/deps/gomod\nexport GOMODCACHE=/tmp/hermeto-output/deps/gomod/pkg/mod\nexport GOPATH=/tmp/hermeto-output/deps/gomod\n</code></pre>"},{"location":"gomod/#inject-project-files","title":"Inject project files","text":"<p>While the <code>gomod</code> package manager does not currently need to modify any content in the source directory to inject the dependencies, the <code>inject-files</code> command should be run to ensure that the operation is performed if this step becomes a requirement in the future.</p> <pre><code>hermeto inject-files ./hermeto-output --for-output-dir /tmp/hermeto-output\n</code></pre>"},{"location":"gomod/#write-the-dockerfile","title":"Write the Dockerfile","text":"<p>As mentioned in the steps above, the only change that needs to be made in the Dockerfile or Dockerfile is to source the environment file before building the binary.</p> <pre><code>FROM golang:1.19.2-alpine3.16 AS build\n\nCOPY ./fzf /src/fzf\nWORKDIR /src/fzf\n\nRUN source /tmp/hermeto.env &amp;&amp; \\\n    go build -o /fzf\n\nFROM registry.access.redhat.com/ubi9/ubi-minimal:9.0.0\n\nCOPY --from=build /fzf /usr/bin/fzf\n\nCMD ls | fzf\n</code></pre>"},{"location":"gomod/#build-the-container","title":"Build the container","text":"<p>Finally, we can build and test the container to ensure that we have successfully built the binary.</p> <pre><code>podman build . \\\n  --volume \"$(realpath ./hermeto-output)\":/tmp/hermeto-output:Z \\\n  --volume \"$(realpath ./hermeto.env)\":/tmp/hermeto.env:Z \\\n  --network none \\\n  --tag fzf\n\n# test that it worked\npodman run --rm -ti fzf\n</code></pre> <ol> <li> <p>You may have noticed a slight naming issue. You use the main argument,   also called PKG, to specify a module to process. Even worse, Go has packages   as well (see gomod vs go-package). What gives? As far   as we know, most languages/package managers use the opposite naming. For   example, in Python, modules are <code>*.py</code> files, packages are collections of   modules. In npm, modules are directories/files you can <code>require()</code>,   packages are the top-level directories with <code>package.json</code>. In Hermeto, we   stick to the more common naming.\u00a0\u21a9</p> </li> <li> <p>When a module does not have a checksum in go.sum, the <code>go list</code> command   returns only basic information and an error for the packages from said module.   Go doesn't return any information about the dependencies of the affected   packages. This can cause Hermeto to miss the transitive package dependencies   of packages from checksum-less modules.\u00a0\u21a9</p> </li> </ol>"},{"location":"npm/","title":"npm","text":"<p>See also the npm docs</p> <ul> <li>Specifying packages to process</li> <li>Project files</li> <li>Dependencies</li> <li>Project example</li> <li>Using fetched dependencies</li> <li>Changes made by the inject-files command</li> <li>Updated project example</li> <li>Full example walkthrough</li> </ul>"},{"location":"npm/#specifying-packages-to-process","title":"Specifying packages to process","text":"<p>A package is a file or directory that is described by a package.json file.</p> <ul> <li> <p>The project files for npm are package.json and one of package-lock.json or   npm-shrinkwrap.json. See Project files and npm   documentation</p> </li> <li> <p>See package.json</p> </li> <li>See package-lock.json</li> </ul> <p>Notice that the package-lock.json version must be higher than v1 (Node.js 15 or higher)! Package-lock.json v1 is not supported in Hermeto.</p> <p>Hermeto can be run as follows</p> <pre><code>hermeto fetch-deps \\\n  --source ./my-repo \\\n  --output ./hermeto-output \\\n  '&lt;JSON input&gt;'\n</code></pre> <p>where 'JSON input' is</p> <pre><code>{\n  // \"npm\" tells Hermeto to process npm packages\n  \"type\": \"npm\",\n  // path to the package (relative to the --source directory)\n  // defaults to \".\"\n  \"path\": \".\",\n}\n</code></pre> <p>or more simply by just invoking <code>hermeto fetch-deps npm</code>.</p>"},{"location":"npm/#project-files","title":"Project files","text":"<p>Hermeto downloads dependencies explicitly declared in project files - package.json and package-lock.json. The npm CLI manages the package-lock.json file automatically. To make sure the file is up to date, you can use npm install.</p> <p>Possible dependency types in the above-mentioned files are described in the following section.</p>"},{"location":"npm/#dependencies","title":"Dependencies","text":"<p>The \"npm package\" formats that Hermeto can process are the following</p> <ol> <li>A folder containing a program described by a 'package.json' file</li> <li>A gzipped tarball containing the previous</li> <li>A URL that resolves to the previous</li> <li>A <code>&lt;name&gt;@&lt;version&gt;</code> that is published on the registry with the previous</li> <li>A <code>&lt;name&gt;@&lt;tag&gt;</code> that points to the previous</li> <li>A <code>&lt;name&gt;</code> that has a latest tag satisfying the previous</li> <li>A git url that, when cloned, results in... the first item in this list</li> </ol> <p>Examples of (package.json) dependency formats</p> <p>(For the full list of dependency formats with explanation, see the npm documentation)</p> Dependencies from npm registries <pre><code>{\n  \"dependencies\": {\n    \"foo\": \"1.0.0 - 2.9999.9999\",\n    \"bar\": \"&gt;=1.0.2 &lt;2.1.2\",\n    \"baz\": \"&gt;1.0.2 &lt;=2.3.4\",\n    \"boo\": \"2.0.1\",\n    ...\n  }\n}\n</code></pre> URLs as dependencies <pre><code>{\n  \"dependencies\": {\n    \"cli_bar\": git+ssh://git@github.com:npm/cli.git#v1.0.27,\n    \"cli_foo\": git://github.com/npm/cli.git#v1.0.1\n  }\n}\n</code></pre> GitHub URLs <pre><code>{\n  \"dependencies\": {\n    \"express\": \"expressjs/express\",\n    \"mocha\": \"mochajs/mocha#4727d357ea\",\n    \"module\": \"user/repo#feature/branch\"\n  }\n}\n</code></pre> Local paths <pre><code>{\n  \"name\": \"baz\",\n  \"dependencies\": {\n    \"bar\": \"file:../foo/bar\"\n  }\n}\n</code></pre>"},{"location":"npm/#project-example","title":"Project example","text":"package.json <pre><code>{\n  \"name\": \"npm-demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"react-dom\": \"^18.0.1\",\n        \"@types/react-dom\": \"^18.0.1\",\n        \"bitbucket-cachi2-npm-without-deps-second\": \"git+https://bitbucket.org/cachi-testing/cachi2-without-deps-second.git\",\n        \"cachito-npm-without-deps\": \"https://github.com/cachito-testing/cachito-npm-without-deps/raw/tarball/cachito-npm-without-deps-1.0.0.tgz\",\n        \"fecha\": \"file:fecha-4.2.3.tgz\"\n  },\n  \"workspaces\": [\n    \"foo\"\n  ]\n}\n</code></pre> package-lock.json <pre><code>{\n  \"name\": \"cachi2-npm-demo\",\n  \"version\": \"1.0.0\",\n  \"lockfileVersion\": 3,\n  \"requires\": true,\n  \"packages\": {\n    \"\": {\n      \"name\": \"cachi2-npm-demo\",\n      \"version\": \"1.0.0\",\n      \"license\": \"ISC\",\n      \"workspaces\": [\n        \"foo\"\n      ],\n      \"dependencies\": {\n        \"@types/react-dom\": \"^18.0.1\",\n        \"bitbucket-cachi2-npm-without-deps-second\": \"git+https://bitbucket.org/cachi-testing/cachi2-without-deps-second.git\",\n        \"cachito-npm-without-deps\": \"https://github.com/cachito-testing/cachito-npm-without-deps/raw/tarball/cachito-npm-without-deps-1.0.0.tgz\",\n        \"fecha\": \"file:fecha-4.2.3.tgz\",\n        \"react-dom\": \"^18.0.1\"\n      }\n    },\n    \"foo\": {\n      \"version\": \"1.0.0\",\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"is-positive\": \"github:kevva/is-positive\"\n      },\n      \"devDependencies\": {}\n    },\n    \"node_modules/@types/prop-types\": {\n      \"version\": \"15.7.5\",\n      \"resolved\": \"https://registry.npmjs.org/@types/prop-types/-/prop-types-15.7.5.tgz\",\n      \"integrity\": \"sha512-JCB8C6SnDoQf0cNycqd/35A7MjcnK+ZTqE7judS6o7utxUCg6imJg3QK2qzHKszlTjcj2cn+NwMB2i96ubpj7w==\"\n    },\n    \"node_modules/@types/react\": {\n      \"version\": \"18.2.18\",\n      \"resolved\": \"https://registry.npmjs.org/@types/react/-/react-18.2.18.tgz\",\n      \"integrity\": \"sha512-da4NTSeBv/P34xoZPhtcLkmZuJ+oYaCxHmyHzwaDQo9RQPBeXV+06gEk2FpqEcsX9XrnNLvRpVh6bdavDSjtiQ==\",\n      \"dependencies\": {\n        \"@types/prop-types\": \"*\",\n        \"@types/scheduler\": \"*\",\n        \"csstype\": \"^3.0.2\"\n      }\n    },\n    \"node_modules/@types/react-dom\": {\n      \"version\": \"18.2.7\",\n      \"resolved\": \"https://registry.npmjs.org/@types/react-dom/-/react-dom-18.2.7.tgz\",\n      \"integrity\": \"sha512-GRaAEriuT4zp9N4p1i8BDBYmEyfo+xQ3yHjJU4eiK5NDa1RmUZG+unZABUTK4/Ox/M+GaHwb6Ow8rUITrtjszA==\",\n      \"dependencies\": {\n        \"@types/react\": \"*\"\n      }\n    },\n    \"node_modules/@types/scheduler\": {\n      \"version\": \"0.16.3\",\n      \"resolved\": \"https://registry.npmjs.org/@types/scheduler/-/scheduler-0.16.3.tgz\",\n      \"integrity\": \"sha512-5cJ8CB4yAx7BH1oMvdU0Jh9lrEXyPkar6F9G/ERswkCuvP4KQZfZkSjcMbAICCpQTN4OuZn8tz0HiKv9TGZgrQ==\"\n    },\n    \"node_modules/bitbucket-cachi2-npm-without-deps-second\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"git+ssh://git@bitbucket.org/cachi-testing/cachi2-without-deps-second.git#09992d418fc44a2895b7a9ff27c4e32d6f74a982\"\n    },\n    \"node_modules/cachito-npm-without-deps\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://github.com/cachito-testing/cachito-npm-without-deps/raw/tarball/cachito-npm-without-deps-1.0.0.tgz\",\n      \"integrity\": \"sha512-Q+cfkK1fnrNJqxiig/iVSZTe83OWLdxhuGa96k1IJJ5nkTxrhNyh6MUZ6YHKH8xitDgpIQSojuntctt2pB7+3g==\"\n    },\n    \"node_modules/csstype\": {\n      \"version\": \"3.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/csstype/-/csstype-3.1.2.tgz\",\n      \"integrity\": \"sha512-I7K1Uu0MBPzaFKg4nI5Q7Vs2t+3gWWW648spaF+Rg7pI9ds18Ugn+lvg4SHczUdKlHI5LWBXyqfS8+DufyBsgQ==\"\n    },\n    \"node_modules/fecha\": {\n      \"version\": \"4.2.3\",\n      \"resolved\": \"file:fecha-4.2.3.tgz\",\n      \"integrity\": \"sha512-OP2IUU6HeYKJi3i0z4A19kHMQoLVs4Hc+DPqqxI2h/DPZHTm/vjsfC6P0b4jCMy14XizLBqvndQ+UilD7707Jw==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/foo\": {\n      \"resolved\": \"foo\",\n      \"link\": true\n    },\n    \"node_modules/is-positive\": {\n      \"version\": \"3.1.0\",\n      \"resolved\": \"git+ssh://git@github.com/kevva/is-positive.git#97edff6f525f192a3f83cea1944765f769ae2678\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"&gt;=0.10.0\"\n      }\n    },\n    \"node_modules/js-tokens\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz\",\n      \"integrity\": \"sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==\"\n    },\n    \"node_modules/loose-envify\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/loose-envify/-/loose-envify-1.4.0.tgz\",\n      \"integrity\": \"sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==\",\n      \"dependencies\": {\n        \"js-tokens\": \"^3.0.0 || ^4.0.0\"\n      },\n      \"bin\": {\n        \"loose-envify\": \"cli.js\"\n      }\n    },\n    \"node_modules/react\": {\n      \"version\": \"18.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/react/-/react-18.2.0.tgz\",\n      \"integrity\": \"sha512-/3IjMdb2L9QbBdWiW5e3P2/npwMBaU9mHCSCUzNln0ZCYbcfTsGbTJrU/kGemdH2IWmB2ioZ+zkxtmq6g09fGQ==\",\n      \"peer\": true,\n      \"dependencies\": {\n        \"loose-envify\": \"^1.1.0\"\n      },\n      \"engines\": {\n        \"node\": \"&gt;=0.10.0\"\n      }\n    },\n    \"node_modules/react-dom\": {\n      \"version\": \"18.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/react-dom/-/react-dom-18.2.0.tgz\",\n      \"integrity\": \"sha512-6IMTriUmvsjHUjNtEDudZfuDQUoWXVxKHhlEGSk81n4YFS+r/Kl99wXiwlVXtPBtJenozv2P+hxDsw9eA7Xo6g==\",\n      \"dependencies\": {\n        \"loose-envify\": \"^1.1.0\",\n        \"scheduler\": \"^0.23.0\"\n      },\n      \"peerDependencies\": {\n        \"react\": \"^18.2.0\"\n      }\n    },\n    \"node_modules/scheduler\": {\n      \"version\": \"0.23.0\",\n      \"resolved\": \"https://registry.npmjs.org/scheduler/-/scheduler-0.23.0.tgz\",\n      \"integrity\": \"sha512-CtuThmgHNg7zIZWAXi3AsyIzA3n4xx7aNyjwC2VJldO2LMVDhFK+63xGqq6CsJH4rTAt6/M+N4GhZiDYPx9eUw==\",\n      \"dependencies\": {\n        \"loose-envify\": \"^1.1.0\"\n      }\n    }\n  }\n}\n</code></pre> foo/package.json (workspace) <pre><code>{\n  \"name\": \"foo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"devDependencies\": {},\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n      \"is-positive\": \"github:kevva/is-positive\"\n  }\n}\n</code></pre>"},{"location":"npm/#using-fetched-dependencies","title":"Using fetched dependencies","text":"<p>See the Example for a complete walkthrough of Hermeto usage.</p> <p>Hermeto downloads the npm dependencies as tar archives into the <code>deps/npm/</code> subpath of the output directory.</p> <ol> <li>Dependencies fetched from npm registries are placed directly to this    directory (array-flatten in the following example).</li> <li>Dependencies downloaded from other HTTPS URL are placed to subdirectory    <code>external-&lt;tarball_name&gt;</code> (bar-project in the following example).</li> <li>Dependencies retrieved from Git repository are placed to <code>host, namespace,    repo</code> subdirectories (foo-project in the following example).</li> </ol> <pre><code>hermeto-output/deps/npm\n\u251c\u2500\u2500 array-flatten-1.1.1.tgz\n\u251c\u2500\u2500 bitbucket.org\n\u2502        \u2514\u2500\u2500 foo-testing\n\u2502             \u2514\u2500\u2500 foo-project\n\u2502                       \u2514\u2500\u2500 foo-project-external-gitcommit-9e164b97043a2d91bbeb992f6cc68a3d1015086a.tgz\n\u251c\u2500\u2500 body-parser-1.20.1.tgz\n\u251c\u2500\u2500 bytes-3.1.2.tgz\n\u2502   ...\n\u251c\u2500\u2500 external-bar-project\n\u2502        \u2514\u2500\u2500 bar-project-external-sha512-43e71f90ad5YOLO.tgz\n\u2502   ...\n</code></pre> <p>In order for the <code>npm install</code> command to use the fetched dependencies instead of reaching for the npm registry, Hermeto needs to update project files. These updates happen automatically when we call Hermeto's <code>inject-files</code> command.</p>"},{"location":"npm/#changes-made-by-the-inject-files-command","title":"Changes made by the inject-files command","text":"<p>The root 'package.json' file is updated together with 'package.json' files for each workspace with changes</p> <ul> <li>For git repositories and HTTPS URLs in dependencies update their value to an   empty string</li> </ul> <p>Hermeto command updates the following in the <code>package-lock.json</code> file</p> <ul> <li>Replace URLs found in resolved items with local paths to   fetched dependencies</li> <li>Similarly to the above package.json changes, for git repositories and HTTPS   URLs in package dependencies update their value to an empty string</li> <li>There is a corner case bug which happens in older npm versions (spotted in   8.12.1 version and lower) where npm mistakenly adds integrity checksum to git   sources. To avoid errors while recreating git repository content as a tar   archive and changing the integrity checksum, Hermeto deletes integrity items,   which should not be there in the first place</li> </ul>"},{"location":"npm/#updated-project-example","title":"Updated project example","text":"package.json <pre><code>{\n  \"name\": \"cachi2-npm-demo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"react-dom\": \"^18.0.1\",\n    \"@types/react-dom\": \"^18.0.1\",\n    \"bitbucket-cachi2-npm-without-deps-second\": \"\",\n    \"cachito-npm-without-deps\": \"\",\n    \"fecha\": \"file:fecha-4.2.3.tgz\"\n  },\n  \"workspaces\": [\n    \"foo\"\n  ]\n}\n</code></pre> package-lock.json <pre><code>{\n  \"name\": \"cachi2-npm-demo\",\n  \"version\": \"1.0.0\",\n  \"lockfileVersion\": 3,\n  \"requires\": true,\n  \"packages\": {\n    \"\": {\n      \"name\": \"cachi2-npm-demo\",\n      \"version\": \"1.0.0\",\n      \"license\": \"ISC\",\n      \"workspaces\": [\n        \"foo\"\n      ],\n      \"dependencies\": {\n        \"@types/react-dom\": \"^18.0.1\",\n        \"bitbucket-cachi2-npm-without-deps-second\": \"\",\n        \"cachito-npm-without-deps\": \"\",\n        \"fecha\": \"file:fecha-4.2.3.tgz\",\n        \"react-dom\": \"^18.0.1\"\n      }\n    },\n    \"foo\": {\n      \"version\": \"1.0.0\",\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"is-positive\": \"\"\n      },\n      \"devDependencies\": {}\n    },\n    \"node_modules/@types/prop-types\": {\n      \"version\": \"15.7.5\",\n      \"resolved\": \"file:///tmp/deps/npm/types-prop-types-15.7.5.tgz\",\n      \"integrity\": \"sha512-JCB8C6SnDoQf0cNycqd/35A7MjcnK+ZTqE7judS6o7utxUCg6imJg3QK2qzHKszlTjcj2cn+NwMB2i96ubpj7w==\"\n    },\n    \"node_modules/@types/react\": {\n      \"version\": \"18.2.18\",\n      \"resolved\": \"file:///tmp/deps/npm/types-react-18.2.18.tgz\",\n      \"integrity\": \"sha512-da4NTSeBv/P34xoZPhtcLkmZuJ+oYaCxHmyHzwaDQo9RQPBeXV+06gEk2FpqEcsX9XrnNLvRpVh6bdavDSjtiQ==\",\n      \"dependencies\": {\n        \"@types/prop-types\": \"*\",\n        \"@types/scheduler\": \"*\",\n        \"csstype\": \"^3.0.2\"\n      }\n    },\n    \"node_modules/@types/react-dom\": {\n      \"version\": \"18.2.7\",\n      \"resolved\": \"file:///tmp/deps/npm/types-react-dom-18.2.7.tgz\",\n      \"integrity\": \"sha512-GRaAEriuT4zp9N4p1i8BDBYmEyfo+xQ3yHjJU4eiK5NDa1RmUZG+unZABUTK4/Ox/M+GaHwb6Ow8rUITrtjszA==\",\n      \"dependencies\": {\n        \"@types/react\": \"*\"\n      }\n    },\n    \"node_modules/@types/scheduler\": {\n      \"version\": \"0.16.3\",\n      \"resolved\": \"file:///tmp/deps/npm/types-scheduler-0.16.3.tgz\",\n      \"integrity\": \"sha512-5cJ8CB4yAx7BH1oMvdU0Jh9lrEXyPkar6F9G/ERswkCuvP4KQZfZkSjcMbAICCpQTN4OuZn8tz0HiKv9TGZgrQ==\"\n    },\n    \"node_modules/bitbucket-cachi2-npm-without-deps-second\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"file:///tmp/deps/npm/bitbucket.org/cachi-testing/cachi2-without-deps-second/cachi2-without-deps-second-external-gitcommit-09992d418fc44a2895b7a9ff27c4e32d6f74a982.tgz\"\n    },\n    \"node_modules/cachito-npm-without-deps\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"file:///tmp/deps/npm/external-cachito-npm-without-deps/cachito-npm-without-deps-external-sha512-43e71f90ad5f9eb349ab18a283f8954994def373962ddc61b866bdea4d48249e67913c6b84dca1e8c519e981ca1fcc62b438292104a88ee9ed72db76a41efede.tgz\",\n      \"integrity\": \"sha512-Q+cfkK1fnrNJqxiig/iVSZTe83OWLdxhuGa96k1IJJ5nkTxrhNyh6MUZ6YHKH8xitDgpIQSojuntctt2pB7+3g==\"\n    },\n    \"node_modules/csstype\": {\n      \"version\": \"3.1.2\",\n      \"resolved\": \"file:///tmp/deps/npm/csstype-3.1.2.tgz\",\n      \"integrity\": \"sha512-I7K1Uu0MBPzaFKg4nI5Q7Vs2t+3gWWW648spaF+Rg7pI9ds18Ugn+lvg4SHczUdKlHI5LWBXyqfS8+DufyBsgQ==\"\n    },\n    \"node_modules/fecha\": {\n      \"version\": \"4.2.3\",\n      \"resolved\": \"file:fecha-4.2.3.tgz\",\n      \"integrity\": \"sha512-OP2IUU6HeYKJi3i0z4A19kHMQoLVs4Hc+DPqqxI2h/DPZHTm/vjsfC6P0b4jCMy14XizLBqvndQ+UilD7707Jw==\",\n      \"license\": \"MIT\"\n    },\n    \"node_modules/foo\": {\n      \"resolved\": \"foo\",\n      \"link\": true\n    },\n    \"node_modules/is-positive\": {\n      \"version\": \"3.1.0\",\n      \"resolved\": \"file:///tmp/deps/npm/github.com/kevva/is-positive/is-positive-external-gitcommit-97edff6f525f192a3f83cea1944765f769ae2678.tgz\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"&gt;=0.10.0\"\n      }\n    },\n    \"node_modules/js-tokens\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"file:///tmp/deps/npm/js-tokens-4.0.0.tgz\",\n      \"integrity\": \"sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==\"\n    },\n    \"node_modules/loose-envify\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"file:///tmp/deps/npm/loose-envify-1.4.0.tgz\",\n      \"integrity\": \"sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==\",\n      \"dependencies\": {\n        \"js-tokens\": \"^3.0.0 || ^4.0.0\"\n      },\n      \"bin\": {\n        \"loose-envify\": \"cli.js\"\n      }\n    },\n    \"node_modules/react\": {\n      \"version\": \"18.2.0\",\n      \"resolved\": \"file:///tmp/deps/npm/react-18.2.0.tgz\",\n      \"integrity\": \"sha512-/3IjMdb2L9QbBdWiW5e3P2/npwMBaU9mHCSCUzNln0ZCYbcfTsGbTJrU/kGemdH2IWmB2ioZ+zkxtmq6g09fGQ==\",\n      \"peer\": true,\n      \"dependencies\": {\n        \"loose-envify\": \"^1.1.0\"\n      },\n      \"engines\": {\n        \"node\": \"&gt;=0.10.0\"\n      }\n    },\n    \"node_modules/react-dom\": {\n      \"version\": \"18.2.0\",\n      \"resolved\": \"file:///tmp/deps/npm/react-dom-18.2.0.tgz\",\n      \"integrity\": \"sha512-6IMTriUmvsjHUjNtEDudZfuDQUoWXVxKHhlEGSk81n4YFS+r/Kl99wXiwlVXtPBtJenozv2P+hxDsw9eA7Xo6g==\",\n      \"dependencies\": {\n        \"loose-envify\": \"^1.1.0\",\n        \"scheduler\": \"^0.23.0\"\n      },\n      \"peerDependencies\": {\n        \"react\": \"^18.2.0\"\n      }\n    },\n    \"node_modules/scheduler\": {\n      \"version\": \"0.23.0\",\n      \"resolved\": \"file:///tmp/deps/npm/scheduler-0.23.0.tgz\",\n      \"integrity\": \"sha512-CtuThmgHNg7zIZWAXi3AsyIzA3n4xx7aNyjwC2VJldO2LMVDhFK+63xGqq6CsJH4rTAt6/M+N4GhZiDYPx9eUw==\",\n      \"dependencies\": {\n        \"loose-envify\": \"^1.1.0\"\n      }\n    }\n  }\n}\n</code></pre> foo/package.json (workspace) <pre><code>{\n  \"name\": \"foo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"devDependencies\": {},\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n      \"is-positive\": \"\"\n  }\n}\n</code></pre>"},{"location":"npm/#example","title":"Example","text":"<p>Let's build simple npm project sample-nodejs-app. Get the repo if you want to try for yourself</p> <pre><code>git clone https://github.com/cachito-testing/sample-nodejs-app.git\n</code></pre>"},{"location":"npm/#pre-fetch-dependencies","title":"Pre-fetch dependencies","text":"<p>The steps for pre-fetching the dependencies is similar to before, but this time we will use the <code>npm</code> package manager type. The default behavior path of <code>.</code> is assumed.</p> <p>See the npm documentation for more details about running Hermeto for pre-fetching npm dependencies.</p> <pre><code>hermeto fetch-deps --source ./sample-nodejs-app --output ./hermeto-output '{\"type\": \"npm\"}'\n</code></pre>"},{"location":"npm/#generate-environment-variables","title":"Generate environment variables","text":"<p>Next, we need to generate the environment file, so we can provide environment variables to the <code>npm install</code> command.</p> <pre><code>hermeto generate-env ./hermeto-output -o ./hermeto.env --for-output-dir /tmp/hermeto-output\n</code></pre> <p>Currently, Hermeto does not require any environment variables for the npm package manager, but this might change in the future.</p>"},{"location":"npm/#inject-project-files","title":"Inject project files","text":"<p>In order to be able to install npm dependencies in a hermetic environment, we need to perform the injection to change the remote dependencies to instead point to the local file system.</p> <pre><code>hermeto inject-files ./hermeto-output --for-output-dir /tmp/hermeto-output\n</code></pre> <p>We can look at the <code>git diff</code> to see what the package remapping looks like. As an example,</p> <pre><code>diff --git a/package-lock.json b/package-lock.json\n-      \"resolved\": \"https://registry.npmjs.org/accepts/-/accepts-1.3.8.tgz\",\n+      \"resolved\": \"file:///tmp/hermeto-output/deps/npm/accepts-1.3.8.tgz\",\n</code></pre>"},{"location":"npm/#build-the-application-image","title":"Build the application image","text":"<p>We will base the final application image on <code>node:18</code> base image. The base image build has <code>npm</code> pre-installed, so the final phase can use network isolation \ud83c\udf89.</p> <pre><code>FROM node:18\n\nCOPY sample-nodejs-app/ /src/sample-nodejs-app\nWORKDIR /src/sample-nodejs-app\n\n# Run npm install command and list installed packages\nRUN . /tmp/hermeto.env &amp;&amp; npm i &amp;&amp; npm ls\n\nEXPOSE 9000\n\nCMD [\"node\", \"index.js\"]\n</code></pre> <p>We can then build the image as before while mounting the required Hermeto data!</p> <pre><code>podman build . \\\n  --volume \"$(realpath ./hermeto-output)\":/tmp/hermeto-output:Z \\\n  --volume \"$(realpath ./hermeto.env)\":/tmp/hermeto.env:Z \\\n  --network none \\\n  --tag sample-nodejs-app\n</code></pre>"},{"location":"pip/","title":"pip","text":"<ul> <li>Specifying packages to process</li> <li>requirements.txt</li> <li>Project metadata</li> <li>Distribution formats</li> <li>Using fetched dependencies</li> <li>Working with Rust-based dependencies</li> <li>Troubleshooting</li> <li>Full example walkthrough</li> </ul>"},{"location":"pip/#specifying-packages-to-process","title":"Specifying packages to process","text":"<p>The \"pip packages\" that Hermeto can process are root directories of Python projects. They should have</p> <ul> <li> <p>One or more requirements files (unless the project has no dependencies)</p> </li> <li> <p>See what Hermeto requires</p> </li> <li> <p>A file defining the project metadata</p> </li> <li> <p>See what Hermeto supports</p> </li> </ul> <p>Then Hermeto can be run as follows</p> <pre><code>hermeto fetch-deps \\\n  --source ./my-repo \\\n  --output ./hermeto-output \\\n  '&lt;JSON input&gt;'\n</code></pre> <p>where 'JSON input' is</p> <pre><code>{\n  \"type\": \"pip\",\n  // path to the package (relative to the --source directory)\n  // defaults to \".\"\n  \"path\": \".\",\n  // specify requirements files (relative to the package path)\n  // defaults to [\"requirements.txt\"] or [] if the file does not exist\n  \"requirements_files\": [\"requirements.txt\", \"requirements-extra.txt\"],\n  // specify *build* requirements files\n  // defaults to [\"requirements-build.txt\"] or [] if the file does not exist\n  \"requirements_build_files\": [\"requirements-build.txt\"],\n  // binary filter object to prefetch specific wheels\n  // defaults to None - only sdists are prefetched by default\n  \"binary\": {\n    \"packages\": \"tensorflow\",\n    \"arch\": \"x86_64\",\n    \"os\": \"linux\",\n    \"py_version\": 312\n  }\n}\n</code></pre> <p>or more simply by just invoking <code>hermeto fetch-deps pip</code>.</p> <p>For more information on using build requirements and binary filter object, see Distribution Formats section.</p> <p>The main argument accepts alternative forms of input, see Example: Pre-fetch dependencies.</p>"},{"location":"pip/#requirementstxt","title":"requirements.txt","text":"<p>Hermeto downloads dependencies explicitly declared in lockfiles. For pip, the closest thing to a lockfile would be a \"fully resolved\" requirements.txt - must contain all the transitive dependencies, must pin them to exact versions.</p> <p>A good way to generate requirements.txt is via pip-compile. Note that pip-compile supports reading dependencies directly from project files (e.g. pyproject.toml, setup.cfg, setup.py) or from \"requirements.in\" input files.</p> Example: pyproject.toml <pre><code>[project]\nname = \"my_package\"\nversion = \"0.1.0\"\ndependencies = [\n    \"requests\",\n    \"dockerfile-parse @ https://github.com/containerbuildsystem/dockerfile-parse/archive/refs/tags/2.0.0.tar.gz\"\n]\n</code></pre> <pre><code>pip-compile pyproject.toml --generate-hashes\n</code></pre> Example: requirements.in <pre><code># requirements.in\nrequests\ndockerfile-parse @ https://github.com/containerbuildsystem/dockerfile-parse/archive/refs/tags/2.0.0.tar.gz\n</code></pre> <pre><code>pip-compile requirements.in --generate-hashes\n</code></pre> Result: requirements.txt <pre><code>#\n# This file is autogenerated by pip-compile with Python 3.10\n# by the following command:\n#\n#    pip-compile --generate-hashes pyproject.toml\n#\ncertifi==2022.12.7 \\\n    --hash=sha256:35824b4c3a97115964b408844d64aa14db1cc518f6562e8d7261699d1350a9e3 \\\n    --hash=sha256:4ad3232f5e926d6718ec31cfc1fcadfde020920e278684144551c91769c7bc18\n    # via requests\ncharset-normalizer==3.0.1 \\\n    --hash=sha256:00d3ffdaafe92a5dc603cb9bd5111aaa36dfa187c8285c543be562e61b755f6b \\\n    --hash=sha256:024e606be3ed92216e2b6952ed859d86b4cfa52cd5bc5f050e7dc28f9b43ec42 \\\n    --hash=sha256:0298eafff88c99982a4cf66ba2efa1128e4ddaca0b05eec4c456bbc7db691d8d \\\n    --hash=sha256:02a51034802cbf38db3f89c66fb5d2ec57e6fe7ef2f4a44d070a593c3688667b \\\n    --hash=sha256:083c8d17153ecb403e5e1eb76a7ef4babfc2c48d58899c98fcaa04833e7a2f9a \\\n    --hash=sha256:0a11e971ed097d24c534c037d298ad32c6ce81a45736d31e0ff0ad37ab437d59 \\\n    --hash=sha256:0bf2dae5291758b6f84cf923bfaa285632816007db0330002fa1de38bfcb7154 \\\n    --hash=sha256:0c0a590235ccd933d9892c627dec5bc7511ce6ad6c1011fdf5b11363022746c1 \\\n    --hash=sha256:0f438ae3532723fb6ead77e7c604be7c8374094ef4ee2c5e03a3a17f1fca256c \\\n    --hash=sha256:109487860ef6a328f3eec66f2bf78b0b72400280d8f8ea05f69c51644ba6521a \\\n    --hash=sha256:11b53acf2411c3b09e6af37e4b9005cba376c872503c8f28218c7243582df45d \\\n    --hash=sha256:12db3b2c533c23ab812c2b25934f60383361f8a376ae272665f8e48b88e8e1c6 \\\n    --hash=sha256:14e76c0f23218b8f46c4d87018ca2e441535aed3632ca134b10239dfb6dadd6b \\\n    --hash=sha256:16a8663d6e281208d78806dbe14ee9903715361cf81f6d4309944e4d1e59ac5b \\\n    --hash=sha256:292d5e8ba896bbfd6334b096e34bffb56161c81408d6d036a7dfa6929cff8783 \\\n    --hash=sha256:2c03cc56021a4bd59be889c2b9257dae13bf55041a3372d3295416f86b295fb5 \\\n    --hash=sha256:2e396d70bc4ef5325b72b593a72c8979999aa52fb8bcf03f701c1b03e1166918 \\\n    --hash=sha256:2edb64ee7bf1ed524a1da60cdcd2e1f6e2b4f66ef7c077680739f1641f62f555 \\\n    --hash=sha256:31a9ddf4718d10ae04d9b18801bd776693487cbb57d74cc3458a7673f6f34639 \\\n    --hash=sha256:356541bf4381fa35856dafa6a965916e54bed415ad8a24ee6de6e37deccf2786 \\\n    --hash=sha256:358a7c4cb8ba9b46c453b1dd8d9e431452d5249072e4f56cfda3149f6ab1405e \\\n    --hash=sha256:37f8febc8ec50c14f3ec9637505f28e58d4f66752207ea177c1d67df25da5aed \\\n    --hash=sha256:39049da0ffb96c8cbb65cbf5c5f3ca3168990adf3551bd1dee10c48fce8ae820 \\\n    --hash=sha256:39cf9ed17fe3b1bc81f33c9ceb6ce67683ee7526e65fde1447c772afc54a1bb8 \\\n    --hash=sha256:3ae1de54a77dc0d6d5fcf623290af4266412a7c4be0b1ff7444394f03f5c54e3 \\\n    --hash=sha256:3b590df687e3c5ee0deef9fc8c547d81986d9a1b56073d82de008744452d6541 \\\n    --hash=sha256:3e45867f1f2ab0711d60c6c71746ac53537f1684baa699f4f668d4c6f6ce8e14 \\\n    --hash=sha256:3fc1c4a2ffd64890aebdb3f97e1278b0cc72579a08ca4de8cd2c04799a3a22be \\\n    --hash=sha256:4457ea6774b5611f4bed5eaa5df55f70abde42364d498c5134b7ef4c6958e20e \\\n    --hash=sha256:44ba614de5361b3e5278e1241fda3dc1838deed864b50a10d7ce92983797fa76 \\\n    --hash=sha256:4a8fcf28c05c1f6d7e177a9a46a1c52798bfe2ad80681d275b10dcf317deaf0b \\\n    --hash=sha256:4b0d02d7102dd0f997580b51edc4cebcf2ab6397a7edf89f1c73b586c614272c \\\n    --hash=sha256:502218f52498a36d6bf5ea77081844017bf7982cdbe521ad85e64cabee1b608b \\\n    --hash=sha256:503e65837c71b875ecdd733877d852adbc465bd82c768a067badd953bf1bc5a3 \\\n    --hash=sha256:5995f0164fa7df59db4746112fec3f49c461dd6b31b841873443bdb077c13cfc \\\n    --hash=sha256:59e5686dd847347e55dffcc191a96622f016bc0ad89105e24c14e0d6305acbc6 \\\n    --hash=sha256:601f36512f9e28f029d9481bdaf8e89e5148ac5d89cffd3b05cd533eeb423b59 \\\n    --hash=sha256:608862a7bf6957f2333fc54ab4399e405baad0163dc9f8d99cb236816db169d4 \\\n    --hash=sha256:62595ab75873d50d57323a91dd03e6966eb79c41fa834b7a1661ed043b2d404d \\\n    --hash=sha256:70990b9c51340e4044cfc394a81f614f3f90d41397104d226f21e66de668730d \\\n    --hash=sha256:71140351489970dfe5e60fc621ada3e0f41104a5eddaca47a7acb3c1b851d6d3 \\\n    --hash=sha256:72966d1b297c741541ca8cf1223ff262a6febe52481af742036a0b296e35fa5a \\\n    --hash=sha256:74292fc76c905c0ef095fe11e188a32ebd03bc38f3f3e9bcb85e4e6db177b7ea \\\n    --hash=sha256:761e8904c07ad053d285670f36dd94e1b6ab7f16ce62b9805c475b7aa1cffde6 \\\n    --hash=sha256:772b87914ff1152b92a197ef4ea40efe27a378606c39446ded52c8f80f79702e \\\n    --hash=sha256:79909e27e8e4fcc9db4addea88aa63f6423ebb171db091fb4373e3312cb6d603 \\\n    --hash=sha256:7e189e2e1d3ed2f4aebabd2d5b0f931e883676e51c7624826e0a4e5fe8a0bf24 \\\n    --hash=sha256:7eb33a30d75562222b64f569c642ff3dc6689e09adda43a082208397f016c39a \\\n    --hash=sha256:81d6741ab457d14fdedc215516665050f3822d3e56508921cc7239f8c8e66a58 \\\n    --hash=sha256:8499ca8f4502af841f68135133d8258f7b32a53a1d594aa98cc52013fff55678 \\\n    --hash=sha256:84c3990934bae40ea69a82034912ffe5a62c60bbf6ec5bc9691419641d7d5c9a \\\n    --hash=sha256:87701167f2a5c930b403e9756fab1d31d4d4da52856143b609e30a1ce7160f3c \\\n    --hash=sha256:88600c72ef7587fe1708fd242b385b6ed4b8904976d5da0893e31df8b3480cb6 \\\n    --hash=sha256:8ac7b6a045b814cf0c47f3623d21ebd88b3e8cf216a14790b455ea7ff0135d18 \\\n    --hash=sha256:8b8af03d2e37866d023ad0ddea594edefc31e827fee64f8de5611a1dbc373174 \\\n    --hash=sha256:8c7fe7afa480e3e82eed58e0ca89f751cd14d767638e2550c77a92a9e749c317 \\\n    --hash=sha256:8eade758719add78ec36dc13201483f8e9b5d940329285edcd5f70c0a9edbd7f \\\n    --hash=sha256:911d8a40b2bef5b8bbae2e36a0b103f142ac53557ab421dc16ac4aafee6f53dc \\\n    --hash=sha256:93ad6d87ac18e2a90b0fe89df7c65263b9a99a0eb98f0a3d2e079f12a0735837 \\\n    --hash=sha256:95dea361dd73757c6f1c0a1480ac499952c16ac83f7f5f4f84f0658a01b8ef41 \\\n    --hash=sha256:9ab77acb98eba3fd2a85cd160851816bfce6871d944d885febf012713f06659c \\\n    --hash=sha256:9cb3032517f1627cc012dbc80a8ec976ae76d93ea2b5feaa9d2a5b8882597579 \\\n    --hash=sha256:9cf4e8ad252f7c38dd1f676b46514f92dc0ebeb0db5552f5f403509705e24753 \\\n    --hash=sha256:9d9153257a3f70d5f69edf2325357251ed20f772b12e593f3b3377b5f78e7ef8 \\\n    --hash=sha256:a152f5f33d64a6be73f1d30c9cc82dfc73cec6477ec268e7c6e4c7d23c2d2291 \\\n    --hash=sha256:a16418ecf1329f71df119e8a65f3aa68004a3f9383821edcb20f0702934d8087 \\\n    --hash=sha256:a60332922359f920193b1d4826953c507a877b523b2395ad7bc716ddd386d866 \\\n    --hash=sha256:a8d0fc946c784ff7f7c3742310cc8a57c5c6dc31631269876a88b809dbeff3d3 \\\n    --hash=sha256:ab5de034a886f616a5668aa5d098af2b5385ed70142090e2a31bcbd0af0fdb3d \\\n    --hash=sha256:c22d3fe05ce11d3671297dc8973267daa0f938b93ec716e12e0f6dee81591dc1 \\\n    --hash=sha256:c2ac1b08635a8cd4e0cbeaf6f5e922085908d48eb05d44c5ae9eabab148512ca \\\n    --hash=sha256:c512accbd6ff0270939b9ac214b84fb5ada5f0409c44298361b2f5e13f9aed9e \\\n    --hash=sha256:c75ffc45f25324e68ab238cb4b5c0a38cd1c3d7f1fb1f72b5541de469e2247db \\\n    --hash=sha256:c95a03c79bbe30eec3ec2b7f076074f4281526724c8685a42872974ef4d36b72 \\\n    --hash=sha256:cadaeaba78750d58d3cc6ac4d1fd867da6fc73c88156b7a3212a3cd4819d679d \\\n    --hash=sha256:cd6056167405314a4dc3c173943f11249fa0f1b204f8b51ed4bde1a9cd1834dc \\\n    --hash=sha256:db72b07027db150f468fbada4d85b3b2729a3db39178abf5c543b784c1254539 \\\n    --hash=sha256:df2c707231459e8a4028eabcd3cfc827befd635b3ef72eada84ab13b52e1574d \\\n    --hash=sha256:e62164b50f84e20601c1ff8eb55620d2ad25fb81b59e3cd776a1902527a788af \\\n    --hash=sha256:e696f0dd336161fca9adbb846875d40752e6eba585843c768935ba5c9960722b \\\n    --hash=sha256:eaa379fcd227ca235d04152ca6704c7cb55564116f8bc52545ff357628e10602 \\\n    --hash=sha256:ebea339af930f8ca5d7a699b921106c6e29c617fe9606fa7baa043c1cdae326f \\\n    --hash=sha256:f4c39b0e3eac288fedc2b43055cfc2ca7a60362d0e5e87a637beac5d801ef478 \\\n    --hash=sha256:f5057856d21e7586765171eac8b9fc3f7d44ef39425f85dbcccb13b3ebea806c \\\n    --hash=sha256:f6f45710b4459401609ebebdbcfb34515da4fc2aa886f95107f556ac69a9147e \\\n    --hash=sha256:f97e83fa6c25693c7a35de154681fcc257c1c41b38beb0304b9c4d2d9e164479 \\\n    --hash=sha256:f9d0c5c045a3ca9bedfc35dca8526798eb91a07aa7a2c0fee134c6c6f321cbd7 \\\n    --hash=sha256:ff6f3db31555657f3163b15a6b7c6938d08df7adbfc9dd13d9d19edad678f1e8\n    # via requests\ndockerfile-parse @ https://github.com/containerbuildsystem/dockerfile-parse/archive/refs/tags/2.0.0.tar.gz \\\n    --hash=sha256:36e4469abb0d96b0e3cd656284d5016e8a674cd57b8ebe5af64786fe63b8184d\n    # via my-package (pyproject.toml)\nidna==3.4 \\\n    --hash=sha256:814f528e8dead7d329833b91c5faa87d60bf71824cd12a7530b5526063d02cb4 \\\n    --hash=sha256:90b77e79eaa3eba6de819a0c442c0b4ceefc341a7a2ab77d7562bf49f425c5c2\n    # via requests\nrequests==2.28.2 \\\n    --hash=sha256:64299f4909223da747622c030b781c0d7811e359c37124b4bd368fb8c6518baa \\\n    --hash=sha256:98b1b2782e3c6c4904938b84c0eb932721069dfdb9134313beff7c83c2df24bf\n    # via my-package (pyproject.toml)\nurllib3==1.26.14 \\\n    --hash=sha256:076907bf8fd355cde77728471316625a4d2f7e713c125f51953bb5b3eecf4f72 \\\n    --hash=sha256:75edcdc2f7d85b137124a6c3c9fc3933cdeaa12ecb9a6a959f22797a0feca7e1\n    # via requests\n</code></pre>"},{"location":"pip/#hashes","title":"Hashes","text":"<p>Using hashes is strongly recommended.</p> <p>If using pip-compile, use the <code>--generate-hashes</code> option.</p>"},{"location":"pip/#external-dependencies","title":"External dependencies","text":"<p>For dependencies coming from somewhere other than PyPI, Hermeto supports a subset of the PEP 440 direct references.</p>"},{"location":"pip/#https-urls","title":"https urls","text":"<pre><code>dockerfile-parse @ https://github.com/containerbuildsystem/dockerfile-parse/archive/refs/tags/2.0.0.tar.gz \\\n    --hash=sha256:36e4469abb0d96b0e3cd656284d5016e8a674cd57b8ebe5af64786fe63b8184d\n</code></pre> <p>For https dependencies, Hermeto requires exactly one <code>--hash</code> option as protection from remote tampering.</p> <p>Note that if at least one dependency in your requirements file uses <code>--hash</code>, pip requires hashes for all dependencies. Use <code>pip-compile --generate-hashes</code> to generate compliant requirements files.</p> <p>Hermeto does not support PEP 440 hashes in the url fragment, only <code>--hash</code> options.</p>"},{"location":"pip/#git-urls","title":"git urls","text":"<pre><code>dockerfile-parse @ git+https://github.com/containerbuildsystem/dockerfile-parse@b6230230987950cfb16d8858c6f9a9642f4d0952\n</code></pre> <p>Git dependencies are incompatible with pip's hash checking. Please use an HTTPS URL instead, if possible</p> <pre><code>- dockerfile-parse @ git+https://github.com/containerbuildsystem/dockerfile-parse@b6230230987950cfb16d8858c6f9a9642f4d0952\n+ dockerfile-parse @ https://github.com/containerbuildsystem/dockerfile-parse/archive/refs/tags/2.0.0.tar.gz \\\n+     --hash=sha256:36e4469abb0d96b0e3cd656284d5016e8a674cd57b8ebe5af64786fe63b8184d\n</code></pre> <p>If you do need to use a git url, Hermeto requires that it specifies a full commit hash.</p> <p>Hermeto does not support PEP 440 commit hashes in the url fragment (the <code>#</code> part), only directly after <code>@</code>.</p> <p>NOTE</p> <p>It's impossible to craft a requirements.txt file that would download dependencies from both https urls and git urls. Hermeto requires hashes for https. Using one --hash makes pip require hashes for everything. Pip does not support hashes for git dependencies. Please use https urls instead.</p>"},{"location":"pip/#supported-options","title":"Supported options","text":"<p>Requirements files support some <code>pip install</code> options - refer to the Pip docs.</p> <p>Hermeto supports a small subset of them, ignores those that are not relevant for prefetching, and raises an error for those that are relevant but aren't supported.</p>"},{"location":"pip/#global","title":"Global","text":""},{"location":"pip/#-index-url","title":"<code>--index-url</code>","text":"<p>Supported since v0.8.0.</p> <p>Make Hermeto download packages from the specified Python Package Index server.</p> <p>NOTE</p> <p>Applies to all the packages (and only the packages) from the file which contains the <code>--index-url</code> option. If file A contains <code>--index-url</code> and file B does not, Hermeto will download the packages declared in B from the default index server (<code>https://pypi.org/simple</code>).</p> <p> Do not include credentials in the index url. If needed, provide authentication via a .netrc file.</p>"},{"location":"pip/#-require-hashes","title":"<code>--require-hashes</code>","text":"<p>Enables hash-checking mode. Typically redundant, since the presence of any <code>--hash</code> option enables hash-checking mode as well.</p>"},{"location":"pip/#-trusted-host","title":"<code>--trusted-host</code>","text":"<p>Disables HTTPS validation for a host. Don't use this for production builds.</p>"},{"location":"pip/#per-requirement","title":"Per-requirement","text":""},{"location":"pip/#-hash","title":"<code>--hash</code>","text":"<p>Specifies the expected hashes for package archives. See also the hashes section.</p>"},{"location":"pip/#project-metadata","title":"Project metadata","text":"<p>Hermeto looks for the name and version of your project in the following project files</p> <ul> <li>pyproject.toml</li> <li>setup.cfg</li> <li>setup.py</li> </ul> <p>If Hermeto fails to resolve the project name, it will generate a name based on the git repository origin url (and package subpath if the package is not in the repository root). If Hermeto fails to resolve the version, it will omit the version.</p>"},{"location":"pip/#pyprojecttoml-pep-621-metadata","title":"pyproject.toml PEP 621 metadata","text":"<p>Supported cases</p> <pre><code>[project]\nname = \"my_package\"\nversion = \"0.1.0\"\n</code></pre> <p>Unsupported cases</p> <pre><code>[project]\nname = \"my_package\"\ndynamic = [\"version\"]\n</code></pre>"},{"location":"pip/#setupcfg-declarative-config","title":"setup.cfg declarative config","text":"<p>Supported cases</p> <pre><code>[metadata]\nname = my_package\nversion = 0.1.0\n</code></pre> <pre><code>[metadata]\nname = my_package\nversion = file: VERSION\n# taken from ./VERSION\n# example content:\n#   0.1.0\n</code></pre> <pre><code>[metadata]\nname = my_package\nversion = attr: my_package.VERSION\n# taken from my_package/__init__.py or my_package.py\n# example content:\n#   VERSION = \"0.1.0\"\n</code></pre> <p>Unsupported cases</p> <ul> <li>missing <code>version</code></li> <li>some forms of <code>version = attr:</code> (those requiring executing the module)</li> </ul>"},{"location":"pip/#setuppy","title":"setup.py","text":"<p>Using setup.py is discouraged.</p> <p>Supported cases</p> <pre><code>setup(name=\"my_package\", version=\"0.1.0\", ...)\n</code></pre> <pre><code># basic variable usage is supported\nNAME = \"my_package\"\nVERSION = \"0.1.0\"\n\nif __name__ == \"__main__\":\n    # setup() call can be anywhere in the file\n    setup(name=NAME, version=VERSION, ...)\n</code></pre>"},{"location":"pip/#distribution-formats","title":"Distribution formats","text":"<p>Python packages typically distribute both the binary format (called wheel) and the source format (called sdist).</p> <p>Wheels are much more convenient; they are the pre-built format, installing from a wheel amounts to unzipping the wheel and copying the files to the right place.</p> <p>Sdists are more difficult to install. Pip must first build a wheel from the sdist using a PEP 517 build system. To do that, pip has to install the build system and its dependencies (defined via PEP 518).</p>"},{"location":"pip/#building-with-wheels","title":"Building with wheels","text":"<p>Building with wheels is helpful when you do not want or cannot build from source. Some projects do not even distribute as sdists. For example, tensorflow (as of version 2.11.0) distributes wheels only.</p> <p>You can use the binary filter object to prefetch the wheels you need to reduce the total download size and ensure compatibility with your target platform.</p> <p>Hermeto supports three binary fetching strategies, analogous to pip's <code>--no-binary</code>, <code>--prefer-binary</code>, and <code>--only-binary</code> options:</p> <ol> <li>No Binaries (default)</li> <li>Configuration: <code>binary</code> field unspecified</li> <li> <p>Behavior: Hermeto operates in source-only mode. No binary artifacts will      be prefetched for any packages. This is the default behavior.</p> </li> <li> <p>Prefer binaries</p> </li> <li>Configuration: <code>binary</code> field specified with <code>packages</code> filter set to <code>:all:</code></li> <li> <p>Behavior</p> <ul> <li>Hermeto will attempt to prefetch compatible binaries for all      dependencies where possible</li> <li>If no matching binary is available, it will attempt to prefetch      sdists instead</li> <li>When binaries are available, Hermeto will attempt to also prefetch an      sdist for each package - this is specifically meant to cover the case      where a specific arch (of more than one specified) doesn't have a      wheel, and the whole build would likely fail otherwise</li> </ul> </li> <li> <p>Only binaries for specific packages</p> </li> <li>Configuration: <code>binary</code> field specified with <code>packages</code> filter set to specific      package names</li> <li>Behavior: For packages in the <code>packages</code> filter, Hermeto will attempt to      prefetch only binaries. If no matching binary can be found for one of these      packages, the operation will fail. Sdists for these packages will not be prefetched.      For packages not in the <code>packages</code> filter, Hermeto falls back to the \"no binary\"      mode above, i.e. only sdists are prefetched.</li> </ol>"},{"location":"pip/#filter-options","title":"Filter Options","text":"<p>The <code>binary</code> object accepts the following filter options:</p> <ul> <li> <p><code>packages</code>: Comma-separated list of package names to limit the filtering scope.   Default: <code>:all:</code>.</p> </li> <li> <p><code>arch</code>: Architecture filter. Accepts comma-separated values. Default: <code>\"x86_64\"</code>.</p> </li> <li> <p><code>os</code>: Operating system filter. Accepts comma-separated values. Default: <code>\"linux\"</code>.</p> </li> <li> <p><code>py_version</code>: Python version filter. Accepts a single integer consisting of   the major and minor versions combined (e.g., 312 for Python 3.12). Default: <code>None</code>.</p> </li> <li> <p><code>py_impl</code>: Python implementation filter. Accepts comma-separated values.   Default: <code>\"cp\"</code>.</p> </li> <li> <p><code>abi</code>: ABI filter. Accepts comma-separated values. Default: <code>:all:</code>.</p> </li> <li> <p><code>platform</code>: Regex pattern to match against platform tags. Default: <code>None</code>.</p> </li> </ul> <p>For more information, see the platform compatibility tags specification.</p>"},{"location":"pip/#filter-logic","title":"Filter Logic","text":"<ul> <li><code>:all:</code> or <code>None</code> are equivalent and mean that no filter is applied</li> <li>multiple values within a single filter field are combined with OR logic</li> <li>multiple filter fields are combined with AND logic</li> <li><code>arch</code> and <code>os</code> are mutually exclusive with <code>platform</code></li> </ul>"},{"location":"pip/#examples","title":"Examples","text":"<p>Prefetch wheels with default filters:</p> <pre><code>{\n  \"type\": \"pip\",\n  \"binary\": {}\n}\n</code></pre> <p>Prefetch wheels for Python 3.12 on Linux aarch64:</p> <pre><code>{\n  \"type\": \"pip\",\n  \"binary\": {\n    \"os\": \"linux\",\n    \"arch\": \"aarch64\",\n    \"py_version\": 312,\n    \"py_impl\": \"cp,pp\"\n  }\n}\n</code></pre> <p>Prefetch wheels for specific packages and platforms:</p> <pre><code>{\n  \"type\": \"pip\",\n  \"binary\": {\n    \"packages\": \"numpy,pandas\",\n    \"platform\": \"^(any|musllinux.*)$\"\n  }\n}\n</code></pre>"},{"location":"pip/#building-from-source","title":"Building from source","text":"<p>Building wheels from sdists takes a long time, but building from source gives you an important guarantee which using pre-built wheels does not: what you installed matches the source code. This can be especially important for Python packages implemented in C or other compiled languages.</p>"},{"location":"pip/#requirements-buildtxt","title":"requirements-build.txt","text":"<p>To allow building from source in a network-isolated environment, Hermeto must download all the PEP 517 build dependencies before the build starts.</p> <p>Hermeto requires a fully resolved requirements-build.txt to do this. The file follows the same rules as requirements.txt, but contains build dependencies rather than runtime dependencies.</p> <p>NOTE</p> <p>This file must contain all the transitive build dependencies of each of your transitive runtime dependencies (you are installing dependencies from source).</p> <p>We recommend the pybuild-deps package to generate the requirements-build.txt file. It will automatically generate build requirements from your requirements.txt file.</p> <p>Adding a requirements-build.txt should not require changes in your build process. Pip should install the build dependencies automatically as needed, you don't have to install them explicitly. The purpose of requirements-build.txt is to make Hermeto fetch the build dependencies and provide them to pip for offline installation.</p>"},{"location":"pip/#using-fetched-dependencies","title":"Using fetched dependencies","text":"<p>See the Example for a complete walkthrough of Hermeto usage.</p> <p>Hermeto downloads the Python dependencies into the deps/pip/ subpath of the output directory. The directory is a flat list of the downloaded distributions of your runtime and build dependencies.</p> <pre><code>hermeto-output/deps/pip\n\u251c\u2500\u2500 certifi-2022.12.7.tar.gz\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 pdm-pep517-1.0.6.tar.gz\n\u251c\u2500\u2500 requests-2.28.2.tar.gz\n\u251c\u2500\u2500 ...\n\u2514\u2500\u2500 wheel-0.38.4.tar.gz\n</code></pre> <p>To make pip use the downloaded archives, use the <code>--find-links</code> and <code>--no-index</code> options. The <code>--find-links</code> option tells pip to look for dependency archives in a directory, <code>--no-index</code> prevents pip from preferring PyPI over the local directory. Pip also accepts environment variables; Hermeto generates <code>PIP_FIND_LINKS</code> and <code>PIP_NO_INDEX</code> for you. See Example: Generate environment variables for more details.</p>"},{"location":"pip/#using-external-dependencies","title":"Using external dependencies","text":"<p>It gets a bit trickier with external dependencies. Pip does not respect the <code>--find-links</code> option for dependencies specified via URLs. Instead, Hermeto's <code>inject-files</code> subcommand rewrites your requirements.txt file(s) in-place to replace the URLs with file paths in the local file system (it is also the case that an environment variable for telling Cargo where to look for prefetched deps is set by <code>inject-files</code>).</p> <pre><code>$ hermeto inject-files ./hermeto-output --for-output-dir /tmp/hermeto-output\n2023-01-26 16:41:09,990 INFO Overwriting /tmp/test/foo-project/requirements.txt\n</code></pre> <p>We can look at the <code>git diff</code> to see what the package remapping looks like. As an example,</p> <pre><code>- dockerfile-parse @ https://github.com/.../2.0.0.tar.gz \\\n+ dockerfile-parse @ file:///absolute-path/hermeto-output/deps/pip/.../dockerfile-parse-...tar.gz\n</code></pre> <p>External dependencies are stored a bit further down the deps/pip tree to avoid mixing them with PyPI dependencies. The path and filename is an implementation detail.</p> <pre><code>hermeto-output/deps/pip\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 external-dockerfile-parse\n\u2502   \u2514\u2500\u2500 dockerfile-parse-external-sha256-36e4469abb0d96b0e3cd656284d5016e8a674cd57b8ebe5af64786fe63b8184d.tar.gz\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"pip/#working-with-rust-based-dependencies","title":"Working with Rust-based dependencies","text":"<p>Hermeto provides a way to prepare hermetic build of a Python package which depends on Rust-based packages. This process cannot be fully automated on Hermeto's side, thus it would require minor intervention from users.</p> <p>Building such project requires that all build dependencies are  listed in requirements-build.txt. To achieve this pybuild-deps could be used. The following command will take care of generating the list</p> <pre><code>pybuild-deps compile --generate-hashes -o requirements-build.txt requirements.txt\n</code></pre> <p>Note that this step requires internet connection.</p> <p>Once requirements-build.txt is populated fetch could be done as usual. Hermeto will fetch all run time and build time dependencies for both Python and Rust parts.</p> <p>Note that a system which is to be used for building these extensions must have <code>rustc</code>, <code>cargo</code>, and all necessary C libraries installed.</p> <p>With these preparations running a pip installation as usual should be sufficient to build and install a Rust-based extension.</p> <p>Note that sometimes Rust-based extensions can break a build. This could happen when such dependency is distributed with a Cargo.lock not matching Cargo.toml (while rare this seems to happen due to peculiarities of the release process for some packages). In this case a package will be rejected with a note about lock file mismatch and an additional report from Cargo about inability to load package lock file due to a mismatch. There is no good solution for this problem on Hermeto's side and the best course of action is to reach out to maintainers of this extension and notify them about the mismatch. Switching to a binary distribution of the package would also resolve this problem at the price of not building it from sources (see Building with wheels for additional context).</p> <pre><code>hermeto --mode permissive fetch-deps pip\n</code></pre> <p>(note that the parameter is global, not a <code>fetch-deps</code>-specific one). This would instruct Cargo PM which handles Rust dependencies to attempt to regenerate Cargo.lock. This is problematic as well since it makes builds unpredictable in the sense that two different builds of the same package can result in different versions of dependencies used because the lock file was regenerated at build time instead of being locked by maintainers. Please be aware that this is still a workaround and that the proper solution is to engage with a package maintainers and ensure that they supply correct Cargo.lock.</p>"},{"location":"pip/#troubleshooting","title":"Troubleshooting","text":"<p>Common issues you may face when fetching dependencies or when installing the fetched dependencies.</p> <p>First, please make sure that your project meets Hermeto's requirements (this document) and that you are using Hermeto as intended (for reference, see the Example for a complete walkthrough).</p>"},{"location":"pip/#miscellaneous-errors-while-building-from-source","title":"Miscellaneous errors while building from source","text":"<p>Have you read Building from source?</p> <p>Even if you have all the build dependencies available, installing from source can come with unforeseen complications. Pip's <code>--no-binary</code> flag can help debug faster.</p> <pre><code># on your machine\nvirtualenv venv &amp;&amp; source venv/bin/activate\n# or in a container\npodman run --rm -ti -v \"$PWD:$PWD:z\" -w \"$PWD\" ubi8/python-39 bash\n\npip install --no-binary :all: -r requirements.txt\n</code></pre> <p>Notably, older versions of pip and setuptools have a fair share of bugs related to PEP 517 handling. A good first course of action can be to upgrade pip and setuptools and try again.</p> <p>Other pip install options such as <code>--use-pep517</code> may also be of interest.</p>"},{"location":"pip/#need-to-install-newer-pip","title":"Need to install newer pip","text":"<p>Problem: you've found out that some build errors are caused by bugs in an older pip version. But the base image for your container build comes with <code>pip==&lt;old&gt;</code> and you cannot upgrade during the build because you're building with network isolation.</p> <p>Solution: make Hermeto fetch a newer pip for you. Then you can upgrade pip from the prefetched archive.</p> <pre><code># add to requirements-build.txt or use a separate file\npip==22.3.1 --hash=...\n</code></pre> <pre><code>RUN source /tmp/hermeto.env &amp;&amp; \\\n    pip install -U pip &amp;&amp; \\\n    pip install .\n</code></pre> <p>You can use a similar approach to upgrade setuptools or other build dependencies before installing your app. Build dependencies other than pip should be part or requirements-build.txt already.</p>"},{"location":"pip/#failing-to-compile-a-dependency","title":"Failing to compile a dependency","text":"<p>Building dependencies written in C typically requires gcc, CPython headers and other development libraries. Hermeto does not fetch these, getting them into the build is up to you. The best case scenario, if you're building a container, is that the base image already contains everything you need. For example, the ubi8/python-39 image contains most of the typical development libraries.</p> <p>To find out what non-Python dependencies you need, try to <code>pip install --no-binary :all:</code> in a clean environment (e.g. a container) as shown above. The error messages you get should hopefully point you to the required dependencies.</p> <p>For dependencies compiled from other languages, such as Rust, we don't know of any good solutions for offline installation. If you do manage to make it work, please let us know.</p>"},{"location":"pip/#dependency-does-not-distribute-sources","title":"Dependency does not distribute sources","text":"<p>Some projects do not distribute sdists to PyPI. For example, tensorflow (as of version 2.11.0) distributes only wheels.</p> <p>Possible workarounds:</p> <ul> <li>Enable pre-fetching wheels using binary filter object in JSON input.</li> <li>Find the git repository for the project, get the source tarball for a release.</li> </ul> <p>In requirements.txt, specify the dependency via an https url.</p> <pre><code>- tensorflow==2.11.0\n+ tensorflow @ https://github.com/tensorflow/tensorflow/archive/refs/tags/v2.11.0.tar.gz \\\n+     --hash=sha256:99c732b92b1b37fc243a559e02f9aef5671771e272758aa4aec7f34dc92dac48\n</code></pre>"},{"location":"pip/#example","title":"Example","text":"<p>Let's build a basic pip project.</p> <p>Get the repo if you want to try for yourself</p> <pre><code>git clone https://github.com/hermetoproject/doc-examples.git --branch=pip-basic\n</code></pre> <p>then <code>cd</code> into the <code>doc-examples</code> directory.</p>"},{"location":"pip/#pre-fetch-dependencies","title":"Pre-fetch dependencies","text":"<p>As mentioned above in Specifying packages to process, Hermeto pre-fetches using the <code>fetch-deps</code> command.</p> <p>Sources can be fetched with</p> <pre><code>hermeto fetch-deps pip\n</code></pre> <p>Note that <code>path</code> is not specified explicitly and defaults to <code>.</code>, and a short-hand notation for package manager is used.</p> <p>It's possible to add parameters in JSON format to point Hermeto at a specific source directory, and/or additional requirements files, if needed, e.g.</p> <pre><code>hermeto fetch-deps --source ./foo-project'{\n  \"type\": \"pip\",\n  \"requirements_files\": [\"requirements.txt\"],\n  \"requirements_build_files\": [\"requirements-build.txt\"]\n}'\n</code></pre>"},{"location":"pip/#generate-environment-variables","title":"Generate environment variables","text":"<p>Next, we need to generate the environment file so that the <code>pip install</code> command can find the cached dependencies</p> <pre><code>hermeto generate-env ./hermeto-output -o ./hermeto.env --for-output-dir /tmp/hermeto-output\n</code></pre> <p>We can see the variables needed by the package manager</p> <pre><code>$ cat hermeto.env\nexport PIP_FIND_LINKS=/tmp/hermeto-output/deps/pip\nexport PIP_NO_INDEX=true\n</code></pre>"},{"location":"pip/#build-the-application-image","title":"Build the application image","text":"<p>In order to support the network isolated build, we need to remember to <code>source</code> the environment file in the step that executes <code>pip install</code>.</p> <p>Dockerfile</p> <pre><code>FROM registry.access.redhat.com/ubi9/python-312\n\nCOPY . /src/simple-color-output\nWORKDIR /src/simple-color-output\n\n# Need to source the hermeto.env file to set the environment variables\n# (in the same RUN instruction as the pip commands)\nRUN source /tmp/hermeto.env \\\n    &amp;&amp; python3 -m pip install -U pip \\\n    &amp;&amp; python3 -m pip install --use-pep517 -r requirements.txt \\\n    &amp;&amp; python3 -m pip install --use-pep517 .\n\nCMD [\"python3\", \"-m\", \"simple_color_output\"]\n</code></pre> <p>After mounting the required Hermeto data, we can then build the image!</p> <pre><code>podman build . \\\n  --volume \"$(realpath ./hermeto-output)\":/tmp/hermeto-output:Z \\\n  --volume \"$(realpath ./hermeto.env)\":/tmp/hermeto.env:Z \\\n  --network none \\\n  --tag simple_color_output\n</code></pre> <p>We can then run the image to see the output</p> <pre><code>podman run --rm simple_color_output:latest\n</code></pre> <p>which should output</p> <p>Hello colorful World!</p> <p>Note that the repo also contains a <code>build.sh</code> script which will execute all of these steps for you.</p>"},{"location":"rpm/","title":"RPM","text":"<ul> <li>Prerequisites</li> <li>RPM lockfile<ul> <li>RPM lockfile format</li> <li>Real world example lockfile</li> </ul> </li> <li>Specifying packages to process</li> <li>Input JSON options<ul> <li>Basic options</li> <li>SSL/TLS configuration</li> <li>DNF repository configuration</li> <li>A complete input example</li> </ul> </li> <li>Using fetched dependencies</li> <li>Changes made by the inject-files command</li> <li>Updated project example</li> <li>Full example walkthrough</li> </ul> <p> This backend is best-effort only and apart from bug fixes we may be reluctant to introduce new functionality (unless trivially added), especially one that would require architectural OR <code>rpms.lock.yaml</code> schema changes simply because there's a native DNF solution in the making which we expect will fully replace and hence deprecate this backend. </p>"},{"location":"rpm/#prerequisites","title":"Prerequisites","text":"<p>To use Hermeto with RPM packages, ensure you have the following tools installed:</p> <ul> <li><code>rpm</code> - for querying package metadata</li> <li><code>createrepo_c</code> - for generating repository metadata during the inject-files    step</li> </ul> <pre><code># On Fedora/RHEL/CentOS\nsudo dnf install rpm-build createrepo_c\n\n# On Debian/Ubuntu\nsudo apt-get install rpm createrepo-c\n</code></pre>"},{"location":"rpm/#rpm-lockfile","title":"RPM lockfile","text":"<p>For the RPM backend in Hermeto to function properly one needs a <code>rpms.lock.yaml</code> file (i.e. a \"lockfile\") which is a fully resolved dependency tree of all RPM packages that need to be downloaded in order to build and run the project. This file can be generated using the rpm-lockfile-prototype tool. Please follow the instructions available on the project's GitHub page for detailed usage information.</p>"},{"location":"rpm/#rpm-lockfile-format","title":"RPM lockfile format","text":"<p>The <code>rpms.lock.yaml</code> file follows a specific YAML schema outlined below that shows required and optional fields:</p> <pre><code># Root level - all fields are required\nlockfileVersion: 1                    # Required: currently must be 1\nlockfileVendor: \"redhat\"              # Required: currently only \"redhat\" is allowed\narches:                               # Required: list of architecture objects\n  - arch: \"string\"                    # Required: architecture name (e.g., x86_64, aarch64)\n\n    # **At least one of 'packages' or 'source' list must be present and non-empty**\n    packages:                         # Optional: list of binary RPM packages\n      - url: \"string\"                 # Required: download URL for the package\n        repoid: \"string\"              # Optional: repository ID\n        checksum: \"string\"            # Optional: package checksum\n        size: integer                 # Optional: file size in bytes\n\n    source:                           # Optional: list of source RPM packages\n      - url: \"string\"                 # Required: download URL for the source package\n        repoid: \"string\"              # Optional: repository ID\n        checksum: \"string\"            # Optional: package checksum\n        size: integer                 # Optional: file size in bytes\n\n    # Modular metadata are needed when installing from RHEL-8 module \"streams\"\n    module_metadata:                  # Optional: list of module metadata files\n      - url: \"string\"                 # Required: download URL for the metadata file\n        repoid: \"string\"              # Required: repository ID (**mandatory for module metadata**)\n        checksum: \"string\"            # Optional: file checksum\n        size: integer                 # Optional: file size in bytes\n</code></pre> <p>Notes on the schema:</p> <ul> <li><code>repoid</code> corresponds to the repository ID as found in <code>.repo</code> files, if    missing in the lockfile a random one will be generated following the   <code>hermeto-UUID[6](-source)?</code> pattern</li> <li><code>checksum</code> format should be <code>algorithm:digest</code> (e.g., <code>sha256:abc123...</code>)</li> <li><code>size</code> represents file size in bytes</li> <li>extra fields may be present in the lockfile (see the example below) that may   be put in there by the generator tool but nothing on top of the schema above   is processed or read by Hermeto</li> </ul>"},{"location":"rpm/#real-world-example-lockfile","title":"Real world example lockfile","text":"rpms.lock.yaml <pre><code>---\nlockfileVersion: 1\nlockfileVendor: redhat\narches:\n- arch: x86_64\n  packages:\n   - url: https://cdn-ubi.redhat.com/content/public/ubi/dist/ubi9/9/x86_64/appstream/os/Packages/a/apr-1.7.0-12.el9_3.x86_64.rpm\n     name: apr\n     repoid: ubi-9-appstream-rpms\n     checksum: sha256:7a8d216d45355f7b656777fcb874a0803d5e97a3e7575b8b58dc7bf608919459\n     size: 129032\n     evr: 1.7.0-12.el9_3                         # extra field\n     sourcerpm: apr-1.7.0-12.el9_3.src.rpm       # extra field\n   - url: https://cdn-ubi.redhat.com/content/public/ubi/dist/ubi9/9/x86_64/appstream/os/Packages/a/apr-util-1.6.1-23.el9.x86_64.rpm\n     repoid: ubi-9-appstream-rpms\n     size: 99555\n     checksum: sha256:fdafa0c878091c68d7e4ff66bdffa2d3a39904351128b55caafc896175651718\n     name: apr-util\n     evr: 1.6.1-23.el9\n     sourcerpm: apr-util-1.6.1-23.el9.src.rpm\n   - url: https://cdn-ubi.redhat.com/content/public/ubi/dist/ubi9/9/x86_64/appstream/os/Packages/a/apr-util-bdb-1.6.1-23.el9.x86_64.rpm\n     repoid: ubi-9-appstream-rpms\n     size: 14447\n     checksum: sha256:d996f1e3b3375cd48b9910f31965e0e8c0df99b553dcac8c4368ac6ed5177623\n     name: apr-util-bdb\n     evr: 1.6.1-23.el9\n     sourcerpm: apr-util-1.6.1-23.el9.src.rpm\n   - url: https://cdn-ubi.redhat.com/content/public/ubi/dist/ubi9/9/x86_64/appstream/os/Packages/h/httpd-tools-2.4.62-4.el9.x86_64.rpm\n     repoid: ubi-9-appstream-rpms\n     size: 87953\n     checksum: sha256:ca56b898a477472c5de44cc2eaf40f0bdebe54508c131fdf63775851f932eed4\n     name: httpd-tools\n     evr: 2.4.62-4.el9\n     sourcerpm: httpd-2.4.62-4.el9.src.rpm\n  source:\n    - url: https://cdn-ubi.redhat.com/content/public/ubi/dist/ubi9/9/x86_64/appstream/source/SRPMS/Packages/a/apr-1.7.0-12.el9_3.src.rpm\n      repoid: ubi-9-appstream-source\n      name: apr\n      evr: 1.7.0-12.el9_3\n      size: 905784\n  module_metadata: []\n</code></pre>"},{"location":"rpm/#specifying-packages-to-process","title":"Specifying packages to process","text":"<p>Hermeto expects to find an <code>rpms.lock.yaml</code> file for each RPM project on the input. The file must be located in the root directory of the given project (which can be a subdirectory from the repository root).</p> <p>Hermeto can be then run as follows:</p> <pre><code>hermeto fetch-deps \\\n  --source ./my-repo \\\n  --output ./hermeto-output \\\n  '&lt;JSON input&gt;'\n</code></pre> <p>where 'JSON input' is:</p> <pre><code>{\n  // \"rpm\" tells Hermeto to process RPM packages\n  \"type\": \"rpm\",\n  // path to the directory containing rpms.lock.yaml (relative to the --source directory)\n  // defaults to \".\"\n  \"path\": \".\"\n}\n</code></pre> <p>or more simply by just invoking <code>hermeto fetch-deps rpm</code>.</p>"},{"location":"rpm/#input-json-options","title":"Input JSON options","text":"<p>The RPM package manager supports several optional configuration parameters in the JSON input:</p>"},{"location":"rpm/#basic-options","title":"Basic options","text":"<pre><code>{\n  \"type\": \"rpm\",\n  \"path\": \".\",\n  \"include_summary_in_sbom\": false    // Include package's `Summary` RPM tag in the SBOM output\n}\n</code></pre>"},{"location":"rpm/#ssltls-configuration","title":"SSL/TLS configuration","text":"<p>For downloading packages from repositories requiring TLS authentication (e.g. Red Hat's CDN for entitled contents):</p> <pre><code>{\n  \"type\": \"rpm\",\n  \"path\": \".\",\n  \"options\": {\n    \"ssl\": {\n      \"client_cert\": \"/path/to/client.crt\",    // Path to client certificate file\n      \"client_key\": \"/path/to/client.key\",     // Path to client private key file\n      \"ca_bundle\": \"/path/to/ca-bundle.crt\",   // Path to CA certificate bundle\n      \"ssl_verify\": true                       // Enable/disable TLS server certificate and hostname\n                                               // verification, DON'T disable unless testing!\n    }\n  }\n}\n</code></pre>"},{"location":"rpm/#dnf-repository-configuration","title":"DNF repository configuration","text":"<p>You can specify additional DNF repository configuration options (see <code>dnf.conf</code> man page) that will be set for a particular repository in the generated <code>hermeto.repo</code> files:</p> <pre><code>{\n  \"type\": \"rpm\",\n  \"path\": \".\",\n  \"options\": {\n    \"dnf\": {                            // These need to be set **per-repository**\n      \"my-repo-id\": {                   // Repository ID from the lockfile\n        \"gpgcheck\": \"0\",                // Disable GPG signature checking\n        \"enabled\": \"1\",                 // Enable the repository\n        \"priority\": \"10\",               // Set repository priority\n        \"sslverify\": \"false\"            // Disable TLS verification for this repo\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"rpm/#a-complete-input-example","title":"A complete input example","text":"<pre><code>{\n  \"type\": \"rpm\",\n  \"path\": \".\",\n  \"include_summary_in_sbom\": true,\n  \"options\": {\n    \"ssl\": {\n      \"client_cert\": \"/etc/pki/client.crt\",\n      \"client_key\": \"/etc/pki/client.key\",\n      \"ssl_verify\": true\n    },\n    \"dnf\": {\n      \"rhel-8-appstream\": {\n        \"gpgcheck\": \"1\",\n        \"priority\": \"10\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"rpm/#using-fetched-dependencies","title":"Using fetched dependencies","text":"<p>See the Example for a complete walkthrough of Hermeto usage.</p> <p>Hermeto downloads the RPM packages and source RPMs into the <code>deps/rpm/</code> subpath of the output directory. The structure is organized by architecture and repository ID:</p> <pre><code>hermeto-output/deps/rpm/\n\u251c\u2500\u2500 x86_64/\n\u2502   \u251c\u2500\u2500 ubi-9-appstream-rpms/\n\u2502   \u2502   \u251c\u2500\u2500 httpd-tools-2.4.62-4.el9.x86_64.rpm\n\u2502   \u2502   \u251c\u2500\u2500 apr-1.7.0-12.el9_3.x86_64.rpm\n\u2502   \u2502   \u251c\u2500\u2500 ...\n\u2502   \u2502   \u2514\u2500\u2500 repos.d/\n\u2502   \u2502       \u2514\u2500\u2500 hermeto.repo\n\u2502   \u2514\u2500\u2500 hermeto-e5ad4c/\n\u2502       \u2514\u2500\u2500 repo-unaffiliated-package-1.0.0-1.x86_64.rpm\n\u2514\u2500\u2500 aarch64/\n    \u2514\u2500\u2500 ubi-9-appstream-rpms/\n        \u251c\u2500\u2500 httpd-tools-2.4.62-4.el9.x86_64.rpm\n        \u251c\u2500\u2500 ...\n        \u2514\u2500\u2500 repos.d/\n            \u2514\u2500\u2500 hermeto.repo\n</code></pre>"},{"location":"rpm/#changes-made-by-the-inject-files-command","title":"Changes made by the inject-files command","text":"<p>The <code>inject-files</code> command performs two important operations for RPM packages:</p> <ol> <li> <p>Repository metadata generation: Uses <code>createrepo_c</code> to generate    repository metadata (repodata) for each repository directory containing RPM    packages.</p> </li> <li> <p>Repository configuration files: Creates <code>hermeto.repo</code> files in each    architecture's <code>repos.d/</code> directory. These files configure DNF/YUM to use the    local packages during installation.</p> </li> </ol> <p>The generated <code>hermeto.repo</code> files contain repository definitions like:</p> <pre><code>[ubi-9-appstream-rpms]\nname=Red Hat Universal Base Image 9 (RPMs) - AppStream\nbaseurl=file:///tmp/hermeto-output/deps/rpm/x86_64/ubi-9-appstream-rpms\ngpgcheck=1\n\n[hermeto-e5ad4c]\nname=Packages unaffiliated with an official repository\nbaseurl=file:///tmp/hermeto-output/deps/rpm/x86_64/hermeto-e5ad4c\ngpgcheck=1\n</code></pre>"},{"location":"rpm/#updated-project-example","title":"Updated project example","text":"<p>After running <code>inject-files</code>, your project directory structure will remain unchanged since RPM packages don't require modification of source files. However, the output directory will contain the generated repository metadata:</p> <pre><code>hermeto-output/deps/rpm/x86_64/ubi-9-appstream-rpms/\n\u251c\u2500\u2500 httpd-tools-2.4.62-4.el9.x86_64.rpm\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 repodata/\n\u2502   \u251c\u2500\u2500 repomd.xml\n\u2502   \u251c\u2500\u2500 primary.xml.gz\n\u2502   \u251c\u2500\u2500 filelists.xml.gz\n\u2502   \u2514\u2500\u2500 other.xml.gz\n\u2514\u2500\u2500 repos.d/\n    \u2514\u2500\u2500 hermeto.repo\n</code></pre>"},{"location":"rpm/#example","title":"Example","text":"<p>Let's demonstrate Hermeto usage with a sample RPM-based app - ApacheBench. Let's start with creating the Containerfile/Dockerfile for the sample app (needed for the lockfile generator tool):</p> <pre><code># Note the base image\nFROM registry.access.redhat.com/ubi9:latest\nRUN dnf -y install httpd-tools\nCMD [\"ab\", \"-V\"]\n</code></pre> <p>We'll assume you have a <code>rpms.lock.yaml</code> file generated by the rpm-lockfile-prototype tool based on the following <code>rpms.in.yaml</code> file:</p> <pre><code>contentOrigin:\n  repos:\n    - repoid: ubi-9-appstream-rpms\n      baseurl: https://cdn-ubi.redhat.com/content/public/ubi/dist/ubi9/9/$basearch/appstream/os\npackages:\n  - name: httpd-tools\n    arches:\n      only: x86_64\ninstallWeakDeps: false\n</code></pre>"},{"location":"rpm/#pre-fetch-dependencies","title":"Pre-fetch dependencies","text":"<p>First, we'll pre-fetch the RPM dependencies specified in the <code>rpms.lock.yaml</code> file:</p> <pre><code>hermeto fetch-deps --source ./&lt;your app directory&gt; rpm\n</code></pre> <p>This command will:</p> <ul> <li>Parse the <code>rpms.lock.yaml</code> file</li> <li>Download all specified RPM packages and source RPMs</li> <li>Verify checksums and file sizes</li> <li>Generate an SBOM with package information</li> </ul>"},{"location":"rpm/#generate-environment-variables","title":"Generate environment variables","text":"<p>Note: The RPM package manager does not require any environment variables, so the <code>generate-env</code> command is not needed for RPM projects. This step can be skipped.</p>"},{"location":"rpm/#inject-project-files","title":"Inject project files","text":"<p>Generate repository metadata and configuration files:</p> <pre><code>hermeto inject-files ./hermeto-output --for-output-dir /tmp/hermeto-output\n</code></pre> <p>This command will:</p> <ul> <li>Create repository metadata using <code>createrepo_c</code></li> <li>Generate <code>hermeto.repo</code> files for DNF/YUM configuration</li> <li>Prepare the package cache for offline installation</li> </ul>"},{"location":"rpm/#build-the-application-image","title":"Build the application image","text":"<p>We're now ready to build the application image using network isolation:</p> <pre><code>podman build . \\\n  --volume \"$(realpath ./hermeto-output)\":/tmp/hermeto-output:Z \\\n  --volume \"$(realpath ./hermeto-output/deps/rpm/x86_64/repos.d)\":/etc/yum.repos.d \\\n  --network none \\\n  --tag my-ab\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<ul> <li>General process</li> <li>Pre-fetch dependencies</li> <li>Generate environment variables</li> <li>Inject project files</li> <li>Merge SBOMs</li> <li>Building the artifact<ul> <li>Set the environment variables</li> <li>Container build example</li> </ul> </li> </ul>"},{"location":"usage/#general-process","title":"General Process","text":"<p>A hermetic build environment is one that is fully encapsulated and isolated from outside influences. When a build is run on a build platform, this encapsulation can guarantee that the platform has a complete picture of all dependencies needed for the build. One class of hermetic build implementations is to restrict external network access during the build itself, requiring that all dependencies are declared and pre-fetched before the build occurs.</p> <p>In order to support this class of hermetic builds, not only does Hermeto need to pre-fetch the dependencies, but some build flows will need additional changes (i.e. leveraging defined environment variables or using Hermeto to inject project files).</p> <p>Hermeto relies on git metadata when processing sources, it expects sources to be a valid git repository with \"origin\" remote defined. This is paramount for successful execution. If for some reason you don't have a git repository, e.g. you're trying to use Hermeto on an unpacked tarball, you may also get acceptable results by forcefully creating a git repository from it first. Make sure to set the remote as well.</p> Workaround to create a local-only git repository <pre>\ngit init &amp;&amp; git add -A &amp;&amp; git commit -m \"initial commit\" &amp;&amp; \\\ngit remote add origin https://github.com/someorg/somerepo\n</pre> WARNING! This is not a substitute for having a proper repository and should be used only for testing!  <p>Note however, that this is only good for smoke testing a scenario and there are no guarantees for any results without proper and correct git metadata, e.g. git tags.</p>"},{"location":"usage/#pre-fetch-dependencies","title":"Pre-fetch dependencies","text":"<p>The first step in creating hermetic builds is to fetch the dependencies for one of the supported package managers.</p> <p>Hermeto can be run as follows</p> <pre><code>hermeto fetch-deps \\\n  --source ./foo \\\n  --output ./hermeto-output \\\n  --sbom-output-type cyclonedx \\\n  '{\"path\": \".\", \"type\": \"&lt;supported package manager&gt;\"}'\n</code></pre> <ul> <li><code>--source</code> the path to a git repository on the local disk <code>[default: .]</code></li> <li><code>--output</code> the path to the directory where Hermeto will write all output   <code>[default: ./hermeto-output]</code></li> <li><code>--sbom-output-type</code> the format of generated SBOM, supported values are   <code>cyclonedx</code> (outputs CycloneDX v1.6) and <code>spdx</code> (outputs SPDX v2.3)   <code>[default: cyclonedx]</code></li> <li><code>{JSON}</code> specifies a package (a directory) within the repository to process</li> </ul> <p>Note that Hermeto does not auto-detect which package managers your project uses. You need to tell Hermeto what to process when calling fetch-deps. In the example above, the package path is located at the root of the foo repo, hence the relative path is <code>.</code>.</p> <p>The main parameter (PKG) can handle different types of definitions</p> <ul> <li>simple: <code>&lt;package manager&gt;</code>, same as <code>{\"path\": \".\", \"type\": \"&lt;package manager&gt;\"}</code></li> <li>JSON object: <code>{\"path\": \"subpath/to/other/module\", \"type\": \"&lt;package manager&gt;\"}</code></li> <li>JSON array: <code>[{\"path\": \".\", \"type\": \"&lt;package manager&gt;\"}, {\"path\":   \"subpath/to/other/module\", \"type\": \"&lt;package manager&gt;\"}]</code></li> <li>JSON object with flags: <code>{\"packages\": [{\"path\": \".\", \"type\": \"&lt;package   manager&gt;\"}], \"flags\": [\"cgo-disable\"]}</code></li> </ul> <p>See also <code>hermeto fetch-deps --help</code>.</p> <p>Using the JSON array object, multiple package managers can be used to resolve dependencies in the same repository.</p> <p>\u26a0 While Hermeto does not intentionally modify the source repository unless the output and source paths are the same, some package managers may add missing data like checksums as dependency data is resolved. If this occurs from a clean git tree then the tree has the possibility to become dirty.</p>"},{"location":"usage/#generate-environment-variables","title":"Generate environment variables","text":"<p>Once the dependencies have been cached, the build process needs to be made aware of the dependencies. Some package managers need to be informed of cache customizations by environment variables.</p> <p>In order to simplify this process, Hermeto provides a helper command to generate the environment variables in an easy-to-use format. The example above uses the \"env\" format which generates a simple shell script that <code>export</code>s the required variables (properly shell quoted when necessary). You can <code>source</code> this file to set the variables.</p> <pre><code>hermeto generate-env ./hermeto-output -o ./hermeto.env --for-output-dir /tmp/hermeto-output\n</code></pre> <ul> <li><code>-o</code> the output path for the generated environment file</li> </ul> <p>Don't worry about the <code>--for-output-dir</code> option yet - and about the fact that the directory does not exist - it has to do with the target path where we will mount the output directory during the build.</p> <p>See also <code>hermeto generate-env --help</code>.</p>"},{"location":"usage/#inject-project-files","title":"Inject project files","text":"<p>While some package managers only need an environment file to be informed of the cache locations, others may need to create a configuration file or edit aBuild the lockfile (or some other file in your project directory).</p> <p>Before starting your build, call <code>hermeto inject-files</code> to automatically make the necessary changes in your repository (based on data in the fetch-deps output directory). Please do not change the absolute path to the repo between the calls to fetch-deps and inject-files; if it's not at the same path, the inject-files command won't find it.</p> <pre><code>hermeto inject-files ./hermeto-output --for-output-dir /tmp/hermeto-output\n</code></pre> <p>The <code>--for-output-dir</code> option has the same meaning as the one used when generating environment variables.</p> <p>\u26a0 Hermeto may overwrite existing files. Please make sure you have no un-committed changes (that you are not prepared to lose) when calling inject-files.</p> <p>\u26a0 Hermeto may change files if required by the package manager. This means that the git status will become dirty if it was previously clean. If any scripting depends on the cleanliness of a git repository and you do not want to commit the changes, the scripting should either be changed to handle the dirty status or the changes should be temporarily stashed by wrapping in <code>git stash &amp;&amp; &lt;command&gt; &amp;&amp; git stash pop</code> according to the suitability of the context.</p>"},{"location":"usage/#merge-sboms","title":"Merge SBOMs","text":"<p>Sometimes it might be necessary to merge two or more SBOMs. This could be done with <code>hermeto merge-sboms</code></p> <pre><code>hermeto merge-sboms &lt;hermeto_sbom_1.json&gt; ... &lt;hermeto_sbom_n.json&gt;\n</code></pre> <p>The subcommand expects at least two SBOMs, all produced by Hermeto, and will exit with error otherwise. The reason for this is that Hermeto supports a limited set of component properties, and it validates that no other properties exist in the SBOM. By default the result of a merge will be printed to stdout. To save it to a file use <code>-o</code> option</p> <pre><code>hermeto merge-sboms &lt;hermeto_sbom_1.json&gt; ... &lt;hermeto_sbom_n.json&gt; -o &lt;merged_sbom.json&gt;\n</code></pre>"},{"location":"usage/#building-the-artifact-with-the-pre-fetched-dependencies","title":"Building the Artifact with the Pre-fetched dependencies","text":"<p>After the pre-fetch and the above steps to inform the package manager(s) of the cache have been completed, it all needs to be wired up into a build. The primary use case for building these is within a Dockerfile or Dockerfile but the same principles can be applied to other build strategies.</p>"},{"location":"usage/#write-the-dockerfile","title":"Write the Dockerfile","text":"<p>Now that we have pre-fetched our dependencies and enabled package manager configuration to point to them, we now need to ensure that the build process (i.e. a Dockerfile or Dockerfile for a container build) is properly written to build in a network isolated mode. All injected files are changed in the source itself, so they will be present in the build context for the Dockerfile. The environment variables added to the <code>hermeto.env</code> file, however, will not be pulled into the build process without a specific action to <code>source</code> the generated file.</p> <p>Outside of this additional <code>source</code> directive in any relevant <code>RUN</code> command, the rest of a container build can remain unchanged.</p> <pre><code>FROM golang:1.19.2-alpine3.16 AS build\n\nCOPY ./foo /src/foo\nWORKDIR /src/foo\n\nRUN source /tmp/hermeto.env &amp;&amp; \\\n    make build\n\nFROM registry.access.redhat.com/ubi9/ubi-minimal:9.0.0\n\nCOPY --from=build /foo /usr/bin/foo\n</code></pre> <p>\u26a0 The <code>source</code>d environment variables do not persist to the next RUN instruction. The sourcing of the file and the package manager command(s) need to be in the same instruction. If the build needs more than one command and you would like to split them into separate RUN instructions, <code>source</code> the environment file in each one.</p> <pre><code>RUN source /tmp/hermeto.env &amp;&amp; \\\n    go build -o /foo cmd/foo &amp;&amp; \\\n    go build -o /bar cmd/bar\n\n# or, if preferable\nRUN source /tmp/hermeto.env &amp;&amp; go build -o /foo cmd/foo\nRUN source /tmp/hermeto.env &amp;&amp; go build -o /bar cmd/bar\n</code></pre>"},{"location":"usage/#build-the-container","title":"Build the container","text":"<p>Now that the Dockerfile or Container file is configured, the next step is to build the container itself. Since more than just the source code context is needed to build the container, we also need to make sure that there are appropriate volumes mounted for the Hermeto output as well as the Hermeto environment variable that is being <code>source</code>d within the build. Since all dependencies are cached, we can confidently restrict the network from the container build as well!</p> <pre><code>podman build . \\\n  --volume \"$(realpath ./hermeto-output)\":/tmp/hermeto-output:Z \\\n  --volume \"$(realpath ./hermeto.env)\":/tmp/hermeto.env:Z \\\n  --network none \\\n  --tag foo\n\n# test that it worked\npodman run --rm -ti foo\n</code></pre> <p>We use the <code>--volume</code> option to mount Hermeto resources into the container build \u2014 the output directory at /tmp/hermeto-output and the environment file at /tmp/hermeto.env.</p> <p>The path where the output directory gets mounted is important. Some environment variables or project files may use absolute paths to content in the output directory; if the directory is not at the expected path, the paths will be wrong. Remember the <code>--for-output-dir</code> option used when generating the env file and injecting the project files? The absolute path to ./hermeto-output on your machine is (probably) not /tmp/hermeto-output. That is why we had to tell the generate-env command what the path inside the container is eventually going to be.</p> <p>In order to run the build with network isolation, use the <code>--network=none</code> option. Note that this option only works if your podman/buildah version contains the fix for buildah#4227 (buildah &gt;= 1.28). In older versions, a workaround could be to manually create an internal network (but you'll need root privileges): <code>sudo podman network create --internal isolated-network; sudo podman build --network isolated-network ...</code>.</p>"},{"location":"yarn/","title":"yarn","text":"<ul> <li>Hermeto's Yarn support scope</li> <li>Supported Yarn versions</li> <li>Supported Yarn protocols/locators</li> <li>Dealing with .yarnrc.yml</li> <li>Dealing with Yarn Zero-Installs</li> <li>Dealing with plugins</li> <li>Specifying packages to process</li> <li>Controlling Yarn's behavior</li> <li>Downloading dependencies</li> <li>Known pitfalls</li> <li>Using fetched dependencies</li> <li>Building your project using the pre-fetched Yarn dependency cache</li> <li>Full example walkthrough</li> </ul>"},{"location":"yarn/#hermetos-yarn-support-scope","title":"Hermeto's Yarn support scope","text":""},{"location":"yarn/#supported-yarn-versions","title":"Supported Yarn versions","text":"<p>Hermeto currently supports Yarn versions 1, 3 and 4. Version 1 is referred to as \"Yarn Classic\" and is covered in Hermeto's Yarn Classic doc. This document describes Yarn v3 and v4 support.</p>"},{"location":"yarn/#supported-yarn-protocolslocators","title":"Supported Yarn protocols/locators","text":"<p>Hermeto currently supports all standard Yarn protocols except for</p> <ul> <li>Exec protocol</li> <li>Git/GitHub protocol</li> </ul> <p>Due to the nature of how the two protocols above work, mainly related to potentially executing arbitrary code, adding support for them with future releases of Hermeto is unlikely. For further details on Yarn protocols and their practical <code>package.json</code> examples, please head to the official Yarn documentation on protocols linked earlier in this section.</p>"},{"location":"yarn/#dealing-with-yarnrcyml","title":"Dealing with .yarnrc.yml","text":"<p>Hermeto parses the project's <code>.yarnrc.yml</code> file and analyzes configuration settings. Before hermeto proceeds with the actual dependency fetching, it verifies whether all configuration settings that set a path to a resource don't point outside of the source repository, so in order to avoid any issues reported by Hermeto in this regard make sure all your project resource references are bound by the repository. Part of the analysis of the repository's <code>.yarnrc.yml</code> file is detection of plugin usage which is further explained in Dealing with plugins.</p>"},{"location":"yarn/#dealing-with-yarn-zero-installs","title":"Dealing with Yarn Zero-Installs","text":"<p>Yarn's PnP Zero-Installs are unsupported due to the potentially unplugged dependencies checked into the repository which simply make it impossible for the Yarn cache to be checked for integrity using Yarn's standard tooling (i.e. <code>yarn install --check-cache</code>).</p> <p>NOTE</p> <p>The same applies to dealing with the <code>node_modules</code> top level directory which, if checked into the repository, can also serve the Zero-Install purpose. If you need further information on which dependency linking mode is used, have a look at the nodeLinker and on the PnP approach in general.</p> <p>Also note that we may reconsider our initial decision when it comes to Zero-Installs provided the input repository doesn't rely on any dependencies which may include install scripts leading to their unpacking in a form of <code>.yarn/unplugged</code> entries.</p>"},{"location":"yarn/#dealing-with-plugins","title":"Dealing with plugins","text":"<p>Due to the nature of plugins (which can potentially execute arbitrary code, by e.g. adding new protocol resolvers), all plugins except for the official ones (see \"Default Plugins\" in the Yarn API docs) are disabled during the dependency prefetch stage to ensure no other changes apart from downloading dependencies took action.</p> <p>For Yarn v3, even the official plugins are disabled, with the exception of exec.</p> <p>NOTE</p> <p>hermeto doesn't taint your project files, so any plugins you set will be enabled normally in your build environment, the only problem that can arise is if any of your specified plugins adds a new protocol which hermeto doesn't know about in which case the dependency pre-fetch stage will fail with an error.</p>"},{"location":"yarn/#specifying-packages-to-process","title":"Specifying packages to process","text":"<p>A package is a file or directory that is described by a package.json file (also called a manifest).</p> <p>Hermeto can be run as follows</p> <pre><code>hermeto fetch-deps \\\n  --source ./my-repo \\\n  --output ./hermeto-output \\\n  '&lt;JSON input&gt;'\n</code></pre> <p>where 'JSON input' is</p> <pre><code>{\n  // \"yarn\" tells Hermeto to process Yarn packages\n  \"type\": \"yarn\",\n  // path to the package (relative to the --source directory)\n  // defaults to \".\"\n  \"path\": \".\",\n}\n</code></pre> <p>or more simply by just invoking <code>hermeto fetch-deps yarn</code>.</p> <p>For complete example of how to pre-fetch dependencies, see Example: Pre-fetch dependencies.</p>"},{"location":"yarn/#controlling-yarns-behavior","title":"Controlling Yarn's behavior","text":"<p>Hermeto instructs Yarn to download dependencies explicitly declared in <code>package.json</code>. The dependencies are then further managed in a <code>yarn.lock</code> file that Yarn CLI manages automatically and creates it if missing. However, Hermeto will refuse to process your repository if the file is missing, so be sure to check that file into the repository. Also make sure that the file is up to date for which you can use yarn install.</p>"},{"location":"yarn/#downloading-dependencies","title":"Downloading dependencies","text":"<p>If Yarn is configured to operate in the PnP mode (the default in Yarn v3 or v4) Yarn will store all dependencies as ZIP archives.</p> <p>Once the source repository analysis and verification described in the earlier sections of this document has been completed, then it's essentially just a matter of hermeto internally invoking <code>yarn install --mode=skip-build</code> to fetch all dependencies (including transitive dependencies).</p>"},{"location":"yarn/#known-pitfalls","title":"Known pitfalls","text":"<p>If your repository isn't in a pristine state (i.e. you tried to run <code>yarn install</code> previously on your own without Hermeto) what may happen is that Hermeto will assume the repository makes use of Zero-Installs. The workaround here is simple, just run <code>yarn cache clean</code> and hermeto will then process your repository as normal.</p>"},{"location":"yarn/#using-fetched-dependencies","title":"Using fetched dependencies","text":"<p>See the Example for a complete walkthrough of Hermeto usage.</p> <p>Hermeto downloads the Yarn dependencies into the <code>deps/yarn/</code> subpath of the output directory (see the snippet below).</p> <pre><code>hermeto-output/deps/yarn\n\u2514\u2500\u2500 cache\n    \u251c\u2500\u2500 abbrev-npm-1.1.1-3659247eab-8.zip\n    \u251c\u2500\u2500 agent-base-npm-6.0.2-428f325a93-8.zip\n    \u251c\u2500\u2500 agentkeepalive-npm-4.3.0-ac3d8e6807-8.zip\n    \u251c\u2500\u2500 aggregate-error-npm-3.1.0-415a406f4e-8.zip\n    \u251c\u2500\u2500 ansi-regex-npm-3.0.1-01f44078a3-8.zip\n...\n</code></pre>"},{"location":"yarn/#building-your-project-using-the-pre-fetched-yarn-dependency-cache","title":"Building your project using the pre-fetched Yarn dependency cache","text":"<p>In order to use the hermeto pre-fetched Yarn dependency cache obtained from the previous step several environment variables need to be set in your build environment. See Example: Generate environment variables for more details on how these can be generated by hermeto automatically in a form of a environment file that can sourced as part of your container build recipe. Here's a snippet of the most important variables hermeto needs to be set in the build environment along with explanation</p> <pre><code># Point Yarn to our pre-populated global cache\nYARN_GLOBAL_FOLDER=&lt;hermeto_output_dir&gt;/deps/yarn\n\n# Yarn must not rely solely on the global cache (the pre-fetched one) because\n# it'll likely only be available (i.e. mounted) during the (container) build\n# time, but not runtime. We specifically want Yarn to copy those dependencies\n# from the global cache to the project's local cache\nYARN_ENABLE_GLOBAL_CACHE=false\n\n# Must be set to true, otherwise Yarn will not make use of the pre-populated\n# global cache we're pointing it at with YARN_GLOBAL_FOLDER at build time.\nYARN_ENABLE_MIRROR=true\n\n# Must be false otherwise 'yarn install' will fail to populate the project's\n# local cache (pointed to by the 'cacheFolder' setting) from the global cache\n# (the pre-fetched one).\nYARN_ENABLE_IMMUTABLE_CACHE=false\n</code></pre>"},{"location":"yarn/#example","title":"Example","text":"<p>For the Yarn example let's use the same sample Node.js project, but this time modified to use Yarn as the package manager. Get the repo if you want to try for yourself</p> <pre><code>git clone -b yarn https://github.com/cachito-testing/sample-nodejs-app.git\n</code></pre>"},{"location":"yarn/#pre-fetch-dependencies","title":"Pre-fetch dependencies","text":"<p>The steps for pre-fetching the dependencies are very similar to the previous examples, this time using the Yarn package manager. Like with the previous examples the default path for the package we assume is <code>.</code>.</p> <p>See the Yarn documentation for more details about running Hermeto for pre-fetching yarn dependencies.</p> <pre><code>hermeto fetch-deps --source ./sample-yarn-app --output ./hermeto-output '{\"type\": \"yarn\"}'\n</code></pre> <p>OR more simply (without the need of a JSON formatted argument) just</p> <pre><code>hermeto fetch-deps --source ./sample-yarn-app --output ./hermeto-output yarn\n</code></pre>"},{"location":"yarn/#generate-environment-variables","title":"Generate environment variables","text":"<p>There are a few environment variables we'll have to set for Yarn during the hermetic build, so we need to generate an environment file.</p> <pre><code>$ hermeto generate-env ./hermeto-output -o ./hermeto.env --for-output-dir /tmp/hermeto-output\n$ cat ./hermeto.env\nexport YARN_ENABLE_GLOBAL_CACHE=false\nexport YARN_ENABLE_IMMUTABLE_CACHE=false\nexport YARN_ENABLE_MIRROR=true\nexport YARN_GLOBAL_FOLDER=/tmp/hermeto-output/deps/yarn\n</code></pre>"},{"location":"yarn/#inject-project-files","title":"Inject project files","text":"<p>Like the <code>gomod</code> package manager Yarn does not currently need to modify any content in the source directory for the cached dependencies to be used in a hermetic build, however that might change in the future.</p>"},{"location":"yarn/#build-the-application-image","title":"Build the application image","text":"<p>Yarn is installed using a Node.js tool called Corepack which has been shipped by Node.js by default since v16.9.0 and v14.19.0. Therefore, we'll use the <code>node:18</code> base image in our example which definitely has Corepack and we can start using Yarn right away.</p> <pre><code>FROM node:18\n\nCOPY sample-yarn-app/ /src/sample-yarn-app\nWORKDIR /src/sample-yarn-app\n\n# Run yarn install command and list installed packages\nRUN . /tmp/hermeto.env &amp;&amp; yarn install\n\nEXPOSE 9000\n\nCMD [\"yarn\", \"run\", \"start\"]\n</code></pre> <p>We can then build the image as before while mounting the required Hermeto data!</p> <pre><code>podman build . \\\n  --volume \"$(realpath ./hermeto-output)\":/tmp/hermeto-output:Z \\\n  --volume \"$(realpath ./hermeto.env)\":/tmp/hermeto.env:Z \\\n  --network none \\\n  --tag sample-nodejs-app\n</code></pre>"},{"location":"yarn_classic/","title":"Yarn Classic (Yarn v1)","text":"<ul> <li>Overview</li> <li>Supported dependencies types</li> <li>Fetching dependencies for Yarn Classic projects</li> <li>Prerequisites for an offline build</li> <li>Limitations and caveats</li> <li>Yarn version specified anywhere in the package will be ignored by prefetch</li> <li>Yarn Zero-Installs are not supported</li> <li>Handling of yarn-specific config files</li> <li>Variables set during fetch phase</li> </ul> <p>This document outlines the differences between Yarn and Yarn Classic support. Please refer to the Yarn documentation for common aspects of Package Manager (PM) behavior. <code>Yarn</code> and <code>Yarn Classic</code> will be used interchangeably in this document, any other versions of Yarn will be explicitly mentioned.</p>"},{"location":"yarn_classic/#overview","title":"Overview","text":"<p>Yarn Classic PM relies on Yarn Classic being installed on the system where Hermeto is run. If requested to process a package with Yarn Classic PM it will check for yarn version and will refuse to proceed if necessary version is missing. Yarn itself is used by Hermeto under the hood to organize package processing with some tweaks to ensure that the packages are prepared to be built in isolation.</p> <p>Hermeto expects to find well-formed <code>package.json</code> and <code>yarn.lock</code> checked in into a repository and will not continue if any of the files are missing. <code>yarn.lock</code> must be up to date and all file or path dependencies must be confined to the project repository.</p> <p>Prefetching dependencies for Yarn in Hermeto is done using Yarn's offline mirror feature. The project must be configured to use the offline mirror feature. Refer to Prerequisites for an offline build for details.</p>"},{"location":"yarn_classic/#supported-dependencies-types","title":"Supported dependencies types","text":"<p>Yarn Classic PM is capable of processing the following types of dependencies</p> <ul> <li>packages from registries</li> <li>packages from git repos</li> <li>packages from http/https URLs</li> <li>packages from local paths</li> <li>local workspace packages</li> <li>local link packages</li> </ul>"},{"location":"yarn_classic/#fetching-dependencies-for-yarn-classic-projects","title":"Fetching dependencies for Yarn Classic projects","text":"<p>The process of fetching dependencies for Yarn Classic is identical to the Yarn backend. Hermeto automatically detects Yarn Classic (i.e. v1) projects and so the logic is all conveniently hidden behind a single <code>yarn</code> CLI backend option.</p> <p>For complete example of how to pre-fetch dependencies for see Yarn documentation.</p>"},{"location":"yarn_classic/#prerequisites-for-an-offline-build","title":"Prerequisites for an offline build","text":"<p>A project that is to be hermetically built must be configured to use an offline mirror. This means that Yarn will store compressed archives on the file system in a mirror directory and will install them from there later without network access.</p> <p>The actual build process will use Yarn directly, thus a project must be configured to use offline mirror either by providing a <code>.yarnrc</code> file or by setting up several environment variables. In case when <code>.yarnrc</code> is preferred it must contain the following lines</p> <pre><code>yarn-offline-mirror &lt;absolute path to the request output directory&gt;\nyarn-offline-mirror-pruning false\n</code></pre> <p>It can be either directly written to or <code>yarn config</code> could be used</p> <pre><code>yarn config set yarn-offline-mirror &lt;absolute path to the request output directory&gt;\nyarn config set yarn-offline-mirror-pruning false\n</code></pre> <p>In case when environment variables approach is preferred the following variables must be set</p> <pre><code>YARN_YARN_OFFLINE_MIRROR=&lt;absolute path to the request output directory&gt;\nYARN_YARN_OFFLINE_MIRROR_PRUNING=false\n</code></pre> <p>Hermeto provides a helper that generates these variables and places them into a file. Sourcing this file is enough to set them.</p>"},{"location":"yarn_classic/#limitations-and-caveats","title":"Limitations and caveats","text":""},{"location":"yarn_classic/#yarn-version-specified-anywhere-in-the-package-will-be-ignored-by-prefetch","title":"Yarn version specified anywhere in the package will be ignored by prefetch","text":"<p>Unlike in the case of Yarn v3 Hermeto will used whichever version is available system-wide on a system where a package is prefetched. In most practical cases this will default to the latest stable version of Yarn Classic (which is not under active development anymore).</p>"},{"location":"yarn_classic/#yarn-zero-installs-are-not-supported","title":"Yarn Zero-Installs are not supported","text":"<p>Yarn Classic's Plug'n'Play feature is not supported. Any package that uses it will be rejected. For further details please refer to Yarn v3 documentation.</p>"},{"location":"yarn_classic/#handling-of-yarn-specific-config-files","title":"Handling of yarn-specific config files","text":"<p>Yarn Classic allows a user to provide additional configuration via .yarnrc and .npmrc. Hermeto ignores these settings during prefetch phase. However a <code>.yarnrc</code> could be used for setting up an offline mirror (see Prerequisites for an offline build). These settings will be applied during a build phase.</p>"},{"location":"yarn_classic/#variables-set-during-fetch-phase","title":"Variables set during fetch phase","text":"<p>The following variables are set for Yarn in the fetch phase</p> <ul> <li><code>COREPACK_ENABLE_DOWNLOAD_PROMPT</code> is set to \"0\" which prevents Corepack from   showing the URL when it needs to download software</li> <li><code>COREPACK_ENABLE_PROJECT_SPEC</code> is set to \"0\" which prevents Corepack from   checking if the package manager corresponds to the one defined for the current   project</li> <li><code>YARN_IGNORE_PATH</code> is set to \"true\" which ignores any Yarn version specified   by a user and uses Corepack's version instead</li> <li><code>YARN_IGNORE_SCRIPTS</code> is set to \"true\" which prevents execution of any scripts   defined in <code>package.json</code> or in any dependency</li> <li><code>YARN_YARN_OFFLINE_MIRROR</code> is set to point to <code>deps/yarn-classic</code> which is   relative to output directory and will hold fetched dependencies</li> <li><code>YARN_YARN_OFFLINE_MIRROR_PRUNING</code> is set to \"false\" which prevents Yarn from   attempting to ensure that dependencies are up to date</li> </ul> <p>Once fetch phase is completed Hermeto will need to generate an environment file with variables pointing to the mirror and instructing Yarn not to prune it</p> <pre><code>YARN_YARN_OFFLINE_MIRROR=&lt;request output directory&gt;\nYARN_YARN_OFFLINE_MIRROR_PRUNING=false\n</code></pre> <p>Sourcing this file will prime Yarn for an offline build.</p>"}]}